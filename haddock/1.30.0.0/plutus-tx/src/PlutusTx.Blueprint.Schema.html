<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><link rel="stylesheet" type="text/css" href="style.css"
     /><script type="text/javascript" src="highlight.js"
    ></script
    ></head
  ><body
  ><pre
    ><span id="local-6989586621679922395"
      ><span id="local-6989586621679922396"
	><span id="local-6989586621679922397"
	  ><span id="local-6989586621679922398"
	    ><span id="local-6989586621679922399"
	      ><span id="local-6989586621679922400"
		><span id="local-6989586621679922401"
		  ><span id="local-6989586621679922402"
		    ><span id="local-6989586621679922403"
		      ><span id="local-6989586621679922404"
			><span id="local-6989586621679922405"
			  ><span id="local-6989586621679922406"
			    ><span id="local-6989586621679922407"
			      ><span id="local-6989586621679922408"
				><span id="local-6989586621679922409"
				  ><span id="local-6989586621679922410"
				    ><span id="local-6989586621679922411"
				      ><span id="local-6989586621679922412"
					><span id="local-6989586621679922413"
					  ><span id="local-6989586621679922414"
					    ><span id="local-6989586621679922415"
					      ><span id="local-6989586621679922416"
						><span id="local-6989586621679922417"
						  ><span id="local-6989586621679922418"
						    ><span id="local-6989586621679922419"
						      ><span id="local-6989586621679922420"
							><span id="local-6989586621679922421"
							  ><span id="local-6989586621679922422"
							    ><span id="local-6989586621679922423"
							      ><span id="local-6989586621679922424"
								><span id="local-6989586621679922425"
								  ></span
								  ></span
								></span
							      ></span
							    ></span
							  ></span
							></span
						      ></span
						    ></span
						  ></span
						></span
					      ></span
					    ></span
					  ></span
					></span
				      ></span
				    ></span
				  ></span
				></span
			      ></span
			    ></span
			  ></span
			></span
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-pragma"
      >{-# LANGUAGE AllowAmbiguousTypes   #-}</span
      ><span
      >
</span
      ><span id="line-2"
      ></span
      ><span class="hs-pragma"
      >{-# LANGUAGE DataKinds             #-}</span
      ><span
      >
</span
      ><span id="line-3"
      ></span
      ><span class="hs-pragma"
      >{-# LANGUAGE DeriveAnyClass        #-}</span
      ><span
      >
</span
      ><span id="line-4"
      ></span
      ><span class="hs-pragma"
      >{-# LANGUAGE DeriveDataTypeable    #-}</span
      ><span
      >
</span
      ><span id="line-5"
      ></span
      ><span class="hs-pragma"
      >{-# LANGUAGE DerivingStrategies    #-}</span
      ><span
      >
</span
      ><span id="line-6"
      ></span
      ><span class="hs-pragma"
      >{-# LANGUAGE DuplicateRecordFields #-}</span
      ><span
      >
</span
      ><span id="line-7"
      ></span
      ><span class="hs-pragma"
      >{-# LANGUAGE LambdaCase            #-}</span
      ><span
      >
</span
      ><span id="line-8"
      ></span
      ><span class="hs-pragma"
      >{-# LANGUAGE NamedFieldPuns        #-}</span
      ><span
      >
</span
      ><span id="line-9"
      ></span
      ><span class="hs-pragma"
      >{-# LANGUAGE OverloadedStrings     #-}</span
      ><span
      >
</span
      ><span id="line-10"
      ></span
      ><span class="hs-pragma"
      >{-# LANGUAGE PolyKinds             #-}</span
      ><span
      >
</span
      ><span id="line-11"
      ></span
      ><span class="hs-pragma"
      >{-# LANGUAGE RecordWildCards       #-}</span
      ><span
      >
</span
      ><span id="line-12"
      ></span
      ><span class="hs-pragma"
      >{-# LANGUAGE TypeFamilies          #-}</span
      ><span
      >
</span
      ><span id="line-13"
      ></span
      ><span class="hs-pragma"
      >{-# LANGUAGE UndecidableInstances  #-}</span
      ><span
      >
</span
      ><span id="line-14"
      ></span
      ><span
      >
</span
      ><span id="line-15"
      ></span
      ><span class="hs-keyword"
      >module</span
      ><span
      > </span
      ><span class="hs-identifier"
      >PlutusTx.Blueprint.Schema</span
      ><span
      > </span
      ><span class="hs-keyword"
      >where</span
      ><span
      >
</span
      ><span id="line-16"
      ></span
      ><span
      >
</span
      ><span id="line-17"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>Control.Lens.Plated</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><span class="hs-identifier"
	>Plated</span
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-18"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>Data.Aeson</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><span class="hs-identifier"
	>ToJSON</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="hs-glyph"
      >..</span
      ><span class="hs-special"
      >)</span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-operator"
	>(.=)</span
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-19"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>Data.Aeson</span
	></span
      ><span
      > </span
      ><span class="hs-keyword"
      >qualified</span
      ><span
      > </span
      ><span class="hs-keyword"
      >as</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>Aeson</span
	></span
      ><span
      >
</span
      ><span id="line-20"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="Data.Aeson.Extra.html"
	><span class="hs-identifier"
	  >Data.Aeson.Extra</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier"
	  >optionalField</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><a href="Data.Aeson.Extra.html#requiredField"
	><span class="hs-identifier"
	  >requiredField</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-21"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>Data.Aeson.KeyMap</span
	></span
      ><span
      > </span
      ><span class="hs-keyword"
      >qualified</span
      ><span
      > </span
      ><span class="hs-keyword"
      >as</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>KeyMap</span
	></span
      ><span
      >
</span
      ><span id="line-22"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>Data.ByteString</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><span class="hs-identifier"
	>ByteString</span
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-23"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>Data.ByteString.Base16</span
	></span
      ><span
      > </span
      ><span class="hs-keyword"
      >qualified</span
      ><span
      > </span
      ><span class="hs-keyword"
      >as</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>Base16</span
	></span
      ><span
      >
</span
      ><span id="line-24"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Data.html"
	><span class="hs-identifier"
	  >Data.Data</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Data.html#Data"
	><span class="hs-identifier"
	  >Data</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Typeable.Internal.html#Typeable"
	><span class="hs-identifier"
	  >Typeable</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-25"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html"
	><span class="hs-identifier"
	  >Data.Function</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator"
	  >(&amp;)</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-26"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Kind.html"
	><span class="hs-identifier"
	  >Data.Kind</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Types.html#Type"
	><span class="hs-identifier"
	  >Type</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-27"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.List.NonEmpty.html"
	><span class="hs-identifier"
	  >Data.List.NonEmpty</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#NonEmpty"
	><span class="hs-identifier"
	  >NonEmpty</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.List.NonEmpty.html#nonEmpty"
	><span class="hs-identifier"
	  >nonEmpty</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-28"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>Data.Text</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><span class="hs-identifier"
	>Text</span
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-29"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>Data.Text.Encoding</span
	></span
      ><span
      > </span
      ><span class="hs-keyword"
      >qualified</span
      ><span
      > </span
      ><span class="hs-keyword"
      >as</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>Text</span
	></span
      ><span
      >
</span
      ><span id="line-30"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Generics.html"
	><span class="hs-identifier"
	  >GHC.Generics</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Generics.html#Generic"
	><span class="hs-identifier"
	  >Generic</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-31"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Numeric.Natural.html"
	><span class="hs-identifier"
	  >Numeric.Natural</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Natural.html#Natural"
	><span class="hs-identifier"
	  >Natural</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-32"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Definition.Id.html"
	><span class="hs-identifier"
	  >PlutusTx.Blueprint.Definition.Id</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Definition.Id.html#DefinitionId"
	><span class="hs-identifier"
	  >DefinitionId</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Definition.Id.html#definitionIdToText"
	><span class="hs-identifier"
	  >definitionIdToText</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-33"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html"
	><span class="hs-identifier"
	  >PlutusTx.Blueprint.Schema.Annotation</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier"
	  >SchemaInfo</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#comment"
	><span class="hs-identifier"
	  >comment</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#description"
	><span class="hs-identifier"
	  >description</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#title"
	><span class="hs-identifier"
	  >title</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-34"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Prelude.html"
	><span class="hs-identifier"
	  >Prelude</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-keyword"
      >hiding</span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#max"
	><span class="hs-identifier"
	  >max</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Foldable.html#maximum"
	><span class="hs-identifier"
	  >maximum</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#min"
	><span class="hs-identifier"
	  >min</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Foldable.html#minimum"
	><span class="hs-identifier"
	  >minimum</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-35"
      ></span
      ><span
      >
</span
      ><span id="line-36"
      ></span
      ><span class="annot"
      ><span class="hs-comment"
	>{- | Blueprint schema definition, as defined by the CIP-0057:
  https://github.com/cardano-foundation/CIPs/tree/master/CIP-0057#core-vocabulary

  The 'referencedTypes' phantom type parameter is used to track the types used in the contract
  making sure their schemas are included in the blueprint and that they are referenced
  in a type-safe way.
-}</span
	></span
      ><span
      >
</span
      ><span id="line-43"
      ></span
      ><span class="hs-keyword"
      >data</span
      ><span
      > </span
      ><span id="Schema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#Schema"
	  ><span class="hs-identifier hs-var"
	    >Schema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span id="local-6989586621679922439"
      ><span class="annot"
	><a href="#local-6989586621679922439"
	  ><span class="hs-identifier hs-type"
	    >referencedTypes</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Types.html#Type"
	><span class="hs-identifier hs-type"
	  >Type</span
	  ></a
	></span
      ><span class="hs-special"
      >]</span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-44"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span id="SchemaInteger"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaInteger"
	  ><span class="hs-identifier hs-var"
	    >SchemaInteger</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#IntegerSchema"
	><span class="hs-identifier hs-type"
	  >IntegerSchema</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-45"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaBytes"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaBytes"
	  ><span class="hs-identifier hs-var"
	    >SchemaBytes</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#BytesSchema"
	><span class="hs-identifier hs-type"
	  >BytesSchema</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-46"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaList"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaList"
	  ><span class="hs-identifier hs-var"
	    >SchemaList</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#ListSchema"
	><span class="hs-identifier hs-type"
	  >ListSchema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922439"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-47"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaMap"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaMap"
	  ><span class="hs-identifier hs-var"
	    >SchemaMap</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#MapSchema"
	><span class="hs-identifier hs-type"
	  >MapSchema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922439"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-48"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaConstructor"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaConstructor"
	  ><span class="hs-identifier hs-var"
	    >SchemaConstructor</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#ConstructorSchema"
	><span class="hs-identifier hs-type"
	  >ConstructorSchema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922439"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-49"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaBuiltInData"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInData"
	  ><span class="hs-identifier hs-var"
	    >SchemaBuiltInData</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-50"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaBuiltInUnit"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInUnit"
	  ><span class="hs-identifier hs-var"
	    >SchemaBuiltInUnit</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-51"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaBuiltInBoolean"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInBoolean"
	  ><span class="hs-identifier hs-var"
	    >SchemaBuiltInBoolean</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-52"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaBuiltInInteger"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInInteger"
	  ><span class="hs-identifier hs-var"
	    >SchemaBuiltInInteger</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-53"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaBuiltInBytes"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInBytes"
	  ><span class="hs-identifier hs-var"
	    >SchemaBuiltInBytes</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-54"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaBuiltInString"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInString"
	  ><span class="hs-identifier hs-var"
	    >SchemaBuiltInString</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-55"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaBuiltInPair"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInPair"
	  ><span class="hs-identifier hs-var"
	    >SchemaBuiltInPair</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#PairSchema"
	><span class="hs-identifier hs-type"
	  >PairSchema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922439"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-56"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaBuiltInList"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInList"
	  ><span class="hs-identifier hs-var"
	    >SchemaBuiltInList</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#Schema"
	><span class="hs-identifier hs-type"
	  >Schema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922439"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-57"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaOneOf"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaOneOf"
	  ><span class="hs-identifier hs-var"
	    >SchemaOneOf</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#NonEmpty"
	><span class="hs-identifier hs-type"
	  >NonEmpty</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#Schema"
	><span class="hs-identifier hs-type"
	  >Schema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922439"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-58"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaAnyOf"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaAnyOf"
	  ><span class="hs-identifier hs-var"
	    >SchemaAnyOf</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#NonEmpty"
	><span class="hs-identifier hs-type"
	  >NonEmpty</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#Schema"
	><span class="hs-identifier hs-type"
	  >Schema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922439"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-59"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaAllOf"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaAllOf"
	  ><span class="hs-identifier hs-var"
	    >SchemaAllOf</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#NonEmpty"
	><span class="hs-identifier hs-type"
	  >NonEmpty</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#Schema"
	><span class="hs-identifier hs-type"
	  >Schema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922439"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-60"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaNot"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaNot"
	  ><span class="hs-identifier hs-var"
	    >SchemaNot</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#Schema"
	><span class="hs-identifier hs-type"
	  >Schema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922439"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-61"
      ></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >|</span
      ><span
      > </span
      ><span id="SchemaDefinitionRef"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#SchemaDefinitionRef"
	  ><span class="hs-identifier hs-var"
	    >SchemaDefinitionRef</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Definition.Id.html#DefinitionId"
	><span class="hs-identifier hs-type"
	  >DefinitionId</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-62"
      ></span
      ><span
      >  </span
      ><span class="hs-keyword"
      >deriving</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-keyword"
	>stock</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span id="local-6989586621679922459"
      ><span id="local-6989586621679922496"
	><span class="annot"
	  ><span class="annottext"
	    >Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
(Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool)
-&gt; (Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool)
-&gt; Eq (Schema referencedTypes)
forall (referencedTypes :: [*]).
Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: forall (referencedTypes :: [*]).
Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
== :: Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
$c/= :: forall (referencedTypes :: [*]).
Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
/= :: Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
</span
	    ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Eq"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Eq</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679922502"
      ><span id="local-6989586621679922539"
	><span id="local-6989586621679922542"
	  ><span id="local-6989586621679922545"
	    ><span id="local-6989586621679922548"
	      ><span id="local-6989586621679922551"
		><span id="local-6989586621679922554"
		  ><span class="annot"
		    ><span class="annottext"
		      >Eq (Schema referencedTypes)
Eq (Schema referencedTypes) =&gt;
(Schema referencedTypes -&gt; Schema referencedTypes -&gt; Ordering)
-&gt; (Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool)
-&gt; (Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool)
-&gt; (Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool)
-&gt; (Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool)
-&gt; (Schema referencedTypes
    -&gt; Schema referencedTypes -&gt; Schema referencedTypes)
-&gt; (Schema referencedTypes
    -&gt; Schema referencedTypes -&gt; Schema referencedTypes)
-&gt; Ord (Schema referencedTypes)
Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
Schema referencedTypes -&gt; Schema referencedTypes -&gt; Ordering
Schema referencedTypes
-&gt; Schema referencedTypes -&gt; Schema referencedTypes
forall (referencedTypes :: [*]). Eq (Schema referencedTypes)
forall (referencedTypes :: [*]).
Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
forall (referencedTypes :: [*]).
Schema referencedTypes -&gt; Schema referencedTypes -&gt; Ordering
forall (referencedTypes :: [*]).
Schema referencedTypes
-&gt; Schema referencedTypes -&gt; Schema referencedTypes
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: forall (referencedTypes :: [*]).
Schema referencedTypes -&gt; Schema referencedTypes -&gt; Ordering
compare :: Schema referencedTypes -&gt; Schema referencedTypes -&gt; Ordering
$c&lt; :: forall (referencedTypes :: [*]).
Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
&lt; :: Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
$c&lt;= :: forall (referencedTypes :: [*]).
Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
&lt;= :: Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
$c&gt; :: forall (referencedTypes :: [*]).
Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
&gt; :: Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
$c&gt;= :: forall (referencedTypes :: [*]).
Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
&gt;= :: Schema referencedTypes -&gt; Schema referencedTypes -&gt; Bool
$cmax :: forall (referencedTypes :: [*]).
Schema referencedTypes
-&gt; Schema referencedTypes -&gt; Schema referencedTypes
max :: Schema referencedTypes
-&gt; Schema referencedTypes -&gt; Schema referencedTypes
$cmin :: forall (referencedTypes :: [*]).
Schema referencedTypes
-&gt; Schema referencedTypes -&gt; Schema referencedTypes
min :: Schema referencedTypes
-&gt; Schema referencedTypes -&gt; Schema referencedTypes
</span
		      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Ord"
		      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
			>Ord</span
			></a
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679922558"
      ><span id="local-6989586621679922614"
	><span id="local-6989586621679922617"
	  ><span class="annot"
	    ><span class="annottext"
	      >Int -&gt; Schema referencedTypes -&gt; ShowS
[Schema referencedTypes] -&gt; ShowS
Schema referencedTypes -&gt; String
(Int -&gt; Schema referencedTypes -&gt; ShowS)
-&gt; (Schema referencedTypes -&gt; String)
-&gt; ([Schema referencedTypes] -&gt; ShowS)
-&gt; Show (Schema referencedTypes)
forall (referencedTypes :: [*]).
Int -&gt; Schema referencedTypes -&gt; ShowS
forall (referencedTypes :: [*]). [Schema referencedTypes] -&gt; ShowS
forall (referencedTypes :: [*]). Schema referencedTypes -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: forall (referencedTypes :: [*]).
Int -&gt; Schema referencedTypes -&gt; ShowS
showsPrec :: Int -&gt; Schema referencedTypes -&gt; ShowS
$cshow :: forall (referencedTypes :: [*]). Schema referencedTypes -&gt; String
show :: Schema referencedTypes -&gt; String
$cshowList :: forall (referencedTypes :: [*]). [Schema referencedTypes] -&gt; ShowS
showList :: [Schema referencedTypes] -&gt; ShowS
</span
	      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Show.html#Show"
	      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
		>Show</span
		></a
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679922621"
      ><span id="local-6989586621679922623"
	><span class="annot"
	  ><span class="annottext"
	    >(forall x.
 Schema referencedTypes -&gt; Rep (Schema referencedTypes) x)
-&gt; (forall x.
    Rep (Schema referencedTypes) x -&gt; Schema referencedTypes)
-&gt; Generic (Schema referencedTypes)
forall (referencedTypes :: [*]) x.
Rep (Schema referencedTypes) x -&gt; Schema referencedTypes
forall (referencedTypes :: [*]) x.
Schema referencedTypes -&gt; Rep (Schema referencedTypes) x
forall x. Rep (Schema referencedTypes) x -&gt; Schema referencedTypes
forall x. Schema referencedTypes -&gt; Rep (Schema referencedTypes) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall (referencedTypes :: [*]) x.
Schema referencedTypes -&gt; Rep (Schema referencedTypes) x
from :: forall x. Schema referencedTypes -&gt; Rep (Schema referencedTypes) x
$cto :: forall (referencedTypes :: [*]) x.
Rep (Schema referencedTypes) x -&gt; Schema referencedTypes
to :: forall x. Rep (Schema referencedTypes) x -&gt; Schema referencedTypes
</span
	    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Generics.html#Generic"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Generic</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679922631"
      ><span id="local-6989586621679922668"
	><span id="local-6989586621679922695"
	  ><span id="local-6989586621679922697"
	    ><span id="local-6989586621679922699"
	      ><span id="local-6989586621679922704"
		><span id="local-6989586621679922709"
		  ><span id="local-6989586621679922712"
		    ><span id="local-6989586621679922715"
		      ><span id="local-6989586621679922718"
			><span id="local-6989586621679922721"
			  ><span id="local-6989586621679922724"
			    ><span id="local-6989586621679922729"
			      ><span id="local-6989586621679922734"
				><span class="annot"
				  ><span class="annottext"
				    >Typeable (Schema referencedTypes)
Typeable (Schema referencedTypes) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; Schema referencedTypes
 -&gt; c (Schema referencedTypes))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Schema referencedTypes))
-&gt; (Schema referencedTypes -&gt; Constr)
-&gt; (Schema referencedTypes -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d))
    -&gt; Maybe (c (Schema referencedTypes)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Schema referencedTypes)))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; Schema referencedTypes -&gt; Schema referencedTypes)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r
    -&gt; (forall d. Data d =&gt; d -&gt; r')
    -&gt; Schema referencedTypes
    -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r
    -&gt; (forall d. Data d =&gt; d -&gt; r')
    -&gt; Schema referencedTypes
    -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; Schema referencedTypes -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Schema referencedTypes -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; Schema referencedTypes -&gt; m (Schema referencedTypes))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; Schema referencedTypes -&gt; m (Schema referencedTypes))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; Schema referencedTypes -&gt; m (Schema referencedTypes))
-&gt; Data (Schema referencedTypes)
Schema referencedTypes -&gt; Constr
Schema referencedTypes -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; Schema referencedTypes -&gt; Schema referencedTypes
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
Typeable (Schema referencedTypes)
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
Schema referencedTypes -&gt; Constr
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
Schema referencedTypes -&gt; DataType
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; Schema referencedTypes -&gt; Schema referencedTypes
forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Schema referencedTypes -&gt; u
forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Schema referencedTypes -&gt; [u]
forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; Schema referencedTypes
-&gt; r
forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; Schema referencedTypes
-&gt; r
forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Schema referencedTypes -&gt; m (Schema referencedTypes)
forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Schema referencedTypes -&gt; m (Schema referencedTypes)
forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Schema referencedTypes)
forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; Schema referencedTypes
-&gt; c (Schema referencedTypes)
forall (referencedTypes :: [*]) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Schema referencedTypes))
forall (referencedTypes :: [*]) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Schema referencedTypes))
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Schema referencedTypes -&gt; u
forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; Schema referencedTypes -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; Schema referencedTypes
-&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; Schema referencedTypes
-&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Schema referencedTypes -&gt; m (Schema referencedTypes)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Schema referencedTypes -&gt; m (Schema referencedTypes)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Schema referencedTypes)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; Schema referencedTypes
-&gt; c (Schema referencedTypes)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Schema referencedTypes))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Schema referencedTypes))
$cgfoldl :: forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; Schema referencedTypes
-&gt; c (Schema referencedTypes)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; Schema referencedTypes
-&gt; c (Schema referencedTypes)
$cgunfold :: forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Schema referencedTypes)
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Schema referencedTypes)
$ctoConstr :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
Schema referencedTypes -&gt; Constr
toConstr :: Schema referencedTypes -&gt; Constr
$cdataTypeOf :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
Schema referencedTypes -&gt; DataType
dataTypeOf :: Schema referencedTypes -&gt; DataType
$cdataCast1 :: forall (referencedTypes :: [*]) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Schema referencedTypes))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Schema referencedTypes))
$cdataCast2 :: forall (referencedTypes :: [*]) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Schema referencedTypes))
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Schema referencedTypes))
$cgmapT :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; Schema referencedTypes -&gt; Schema referencedTypes
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; Schema referencedTypes -&gt; Schema referencedTypes
$cgmapQl :: forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; Schema referencedTypes
-&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; Schema referencedTypes
-&gt; r
$cgmapQr :: forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; Schema referencedTypes
-&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; Schema referencedTypes
-&gt; r
$cgmapQ :: forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Schema referencedTypes -&gt; [u]
gmapQ :: forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; Schema referencedTypes -&gt; [u]
$cgmapQi :: forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Schema referencedTypes -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Schema referencedTypes -&gt; u
$cgmapM :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Schema referencedTypes -&gt; m (Schema referencedTypes)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Schema referencedTypes -&gt; m (Schema referencedTypes)
$cgmapMp :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Schema referencedTypes -&gt; m (Schema referencedTypes)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Schema referencedTypes -&gt; m (Schema referencedTypes)
$cgmapMo :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Schema referencedTypes -&gt; m (Schema referencedTypes)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Schema referencedTypes -&gt; m (Schema referencedTypes)
</span
				    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Data.html#Data"
				    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
				      >Data</span
				      ></a
				    ></span
				  ></span
				></span
			      ></span
			    ></span
			  ></span
			></span
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-63"
      ></span
      ><span
      >
</span
      ><span id="line-64"
      ></span
      ><span id="local-6989586621679922741"
      ><span class="hs-keyword"
	>deriving</span
	><span
	> </span
	><span id="local-6989586621679922118"
	><span class="annot"
	  ><a href="#local-6989586621679922118"
	    ><span class="hs-keyword hs-type"
	      >anyclass</span
	      ></a
	    ></span
	  ></span
	><span
	> </span
	><span class="hs-keyword"
	>instance</span
	><span
	> </span
	><span class="hs-special"
	>(</span
	><span class="annot"
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Typeable.Internal.html#Typeable"
	  ><span class="hs-identifier hs-type"
	    >Typeable</span
	    ></a
	  ></span
	><span
	> </span
	><span class="annot"
	><a href="#local-6989586621679922118"
	  ><span class="hs-identifier hs-type"
	    >referencedTypes</span
	    ></a
	  ></span
	><span class="hs-special"
	>)</span
	><span
	> </span
	><span class="hs-glyph"
	>=&gt;</span
	><span
	> </span
	><span class="annot"
	><span class="hs-identifier hs-type"
	  >Plated</span
	  ></span
	><span
	> </span
	><span class="hs-special"
	>(</span
	><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#Schema"
	  ><span class="hs-identifier hs-type"
	    >Schema</span
	    ></a
	  ></span
	><span
	> </span
	><span class="annot"
	><a href="#local-6989586621679922118"
	  ><span class="hs-identifier hs-type"
	    >referencedTypes</span
	    ></a
	  ></span
	><span class="hs-special"
	>)</span
	></span
      ><span
      >
</span
      ><span id="line-65"
      ></span
      ><span
      >
</span
      ><span id="line-66"
      ></span
      ><span class="hs-keyword"
      >instance</span
      ><span
      > </span
      ><span id="local-6989586621679922124"
      ><span id="local-6989586621679922750"
	><span id="local-6989586621679922754"
	  ><span id="local-6989586621679922757"
	    ><span id="local-6989586621679922760"
	      ><span class="annot"
		><span class="hs-identifier hs-type"
		  >ToJSON</span
		  ></span
		><span
		> </span
		><span class="hs-special"
		>(</span
		><span class="annot"
		><a href="PlutusTx.Blueprint.Schema.html#Schema"
		  ><span class="hs-identifier hs-type"
		    >Schema</span
		    ></a
		  ></span
		><span
		> </span
		><span class="annot"
		><a href="#local-6989586621679922124"
		  ><span class="hs-identifier hs-type"
		    >referencedTypes</span
		    ></a
		  ></span
		><span class="hs-special"
		>)</span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-keyword"
      >where</span
      ><span
      >
</span
      ><span id="line-67"
      ></span
      ><span
      >  </span
      ><span id="local-6989586621679922849"
      ><span class="annot"
	><span class="annottext"
	  >toJSON :: Schema referencedTypes -&gt; Value
</span
	  ><a href="#local-6989586621679922849"
	  ><span class="hs-identifier hs-var hs-var hs-var hs-var"
	    >toJSON</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="hs-glyph"
      >\</span
      ><span class="hs-glyph"
      >case</span
      ><span
      >
</span
      ><span id="line-68"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaInteger"
	><span class="hs-identifier hs-type"
	  >SchemaInteger</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922851"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922851"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#MkIntegerSchema"
	><span class="hs-identifier hs-type"
	  >MkIntegerSchema</span
	  ></a
	></span
      ><span class="hs-special"
      >{</span
      ><span id="local-6989586621679922853"
      ><span id="local-6989586621679922854"
	><span id="local-6989586621679922855"
	  ><span id="local-6989586621679922856"
	    ><span id="local-6989586621679922857"
	      ><span class="annot"
		><span class="annottext"
		  >Maybe Integer
multipleOf :: Maybe Integer
minimum :: Maybe Integer
maximum :: Maybe Integer
exclusiveMinimum :: Maybe Integer
exclusiveMaximum :: Maybe Integer
$sel:multipleOf:MkIntegerSchema :: IntegerSchema -&gt; Maybe Integer
$sel:minimum:MkIntegerSchema :: IntegerSchema -&gt; Maybe Integer
$sel:maximum:MkIntegerSchema :: IntegerSchema -&gt; Maybe Integer
$sel:exclusiveMinimum:MkIntegerSchema :: IntegerSchema -&gt; Maybe Integer
$sel:exclusiveMaximum:MkIntegerSchema :: IntegerSchema -&gt; Maybe Integer
</span
		  ><a href="#local-6989586621679922853"
		  ><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
		    >..</span
		    ></a
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >}</span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-69"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; String -&gt; Object
</span
	><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-var"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922851"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><span class="hs-string"
	>&quot;integer&quot;</span
	></span
      ><span
      >
</span
      ><span id="line-70"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe Integer -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;multipleOf&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Integer
</span
	><a href="#local-6989586621679922853"
	><span class="hs-identifier hs-var"
	  >multipleOf</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-71"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe Integer -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;minimum&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Integer
</span
	><a href="#local-6989586621679922854"
	><span class="hs-identifier hs-var"
	  >minimum</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-72"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe Integer -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;maximum&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Integer
</span
	><a href="#local-6989586621679922855"
	><span class="hs-identifier hs-var"
	  >maximum</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-73"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe Integer -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;exclusiveMinimum&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Integer
</span
	><a href="#local-6989586621679922856"
	><span class="hs-identifier hs-var"
	  >exclusiveMinimum</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-74"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe Integer -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;exclusiveMaximum&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Integer
</span
	><a href="#local-6989586621679922857"
	><span class="hs-identifier hs-var"
	  >exclusiveMaximum</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-75"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Value) -&gt; Value
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      >
</span
      ><span id="line-76"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaBytes"
	><span class="hs-identifier hs-type"
	  >SchemaBytes</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922865"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922865"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#MkBytesSchema"
	><span class="hs-identifier hs-type"
	  >MkBytesSchema</span
	  ></a
	></span
      ><span class="hs-special"
      >{</span
      ><span id="local-6989586621679922867"
      ><span id="local-6989586621679922868"
	><span id="local-6989586621679922869"
	  ><span class="annot"
	    ><span class="annottext"
	      >[ByteString]
Maybe Natural
enum :: [ByteString]
minLength :: Maybe Natural
maxLength :: Maybe Natural
$sel:enum:MkBytesSchema :: BytesSchema -&gt; [ByteString]
$sel:minLength:MkBytesSchema :: BytesSchema -&gt; Maybe Natural
$sel:maxLength:MkBytesSchema :: BytesSchema -&gt; Maybe Natural
</span
	      ><a href="#local-6989586621679922867"
	      ><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var"
		>..</span
		></a
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >}</span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-77"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; String -&gt; Object
</span
	><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-var"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922865"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><span class="hs-string"
	>&quot;bytes&quot;</span
	></span
      ><span
      >
</span
      ><span id="line-78"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe (NonEmpty Text) -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;enum&quot;</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><span class="annottext"
	>(ByteString -&gt; Text) -&gt; NonEmpty ByteString -&gt; NonEmpty Text
forall a b. (a -&gt; b) -&gt; NonEmpty a -&gt; NonEmpty b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#fmap"
	><span class="hs-identifier hs-var"
	  >fmap</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>ByteString -&gt; Text
</span
	><a href="#local-6989586621679922873"
	><span class="hs-identifier hs-var"
	  >toHex</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(NonEmpty ByteString -&gt; NonEmpty Text)
-&gt; Maybe (NonEmpty ByteString) -&gt; Maybe (NonEmpty Text)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Functor.html#%3C%24%3E"
	><span class="hs-operator hs-var"
	  >&lt;$&gt;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>[ByteString] -&gt; Maybe (NonEmpty ByteString)
forall a. [a] -&gt; Maybe (NonEmpty a)
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.List.NonEmpty.html#nonEmpty"
	><span class="hs-identifier hs-var"
	  >nonEmpty</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>[ByteString]
</span
	><a href="#local-6989586621679922867"
	><span class="hs-identifier hs-var"
	  >enum</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-79"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe Natural -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;maxLength&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Natural
</span
	><a href="#local-6989586621679922869"
	><span class="hs-identifier hs-var"
	  >maxLength</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-80"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe Natural -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;minLength&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Natural
</span
	><a href="#local-6989586621679922868"
	><span class="hs-identifier hs-var"
	  >minLength</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-81"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Value) -&gt; Value
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      >
</span
      ><span id="line-82"
      ></span
      ><span
      >     </span
      ><span class="hs-keyword"
      >where</span
      ><span
      >
</span
      ><span id="line-83"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><a href="#local-6989586621679922873"
	><span class="hs-identifier hs-type"
	  >toHex</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier hs-type"
	>ByteString</span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier hs-type"
	>Text</span
	></span
      ><span
      >
</span
      ><span id="line-84"
      ></span
      ><span
      >      </span
      ><span id="local-6989586621679922873"
      ><span class="annot"
	><span class="annottext"
	  >toHex :: ByteString -&gt; Text
</span
	  ><a href="#local-6989586621679922873"
	  ><span class="hs-identifier hs-var hs-var"
	    >toHex</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>ByteString -&gt; Text
</span
	><span class="hs-identifier hs-var"
	>Text.decodeUtf8</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(ByteString -&gt; Text)
-&gt; (ByteString -&gt; ByteString) -&gt; ByteString -&gt; Text
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#."
	><span class="hs-operator hs-var"
	  >.</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>ByteString -&gt; ByteString
</span
	><span class="hs-identifier hs-var"
	>Base16.encode</span
	></span
      ><span
      >
</span
      ><span id="line-85"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaList"
	><span class="hs-identifier hs-type"
	  >SchemaList</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922878"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922878"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#MkListSchema"
	><span class="hs-identifier hs-type"
	  >MkListSchema</span
	  ></a
	></span
      ><span class="hs-special"
      >{</span
      ><span id="local-6989586621679922880"
      ><span id="local-6989586621679922881"
	><span id="local-6989586621679922882"
	  ><span id="local-6989586621679922883"
	    ><span class="annot"
	      ><span class="annottext"
		>Maybe Bool
Maybe Natural
Schema referencedTypes
itemSchema :: Schema referencedTypes
minItems :: Maybe Natural
maxItems :: Maybe Natural
uniqueItems :: Maybe Bool
$sel:itemSchema:MkListSchema :: forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; Schema referencedTypes
$sel:minItems:MkListSchema :: forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; Maybe Natural
$sel:maxItems:MkListSchema :: forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; Maybe Natural
$sel:uniqueItems:MkListSchema :: forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; Maybe Bool
</span
		><a href="#local-6989586621679922880"
		><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
		  >..</span
		  ></a
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >}</span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-86"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; String -&gt; Object
</span
	><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-var"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922878"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><span class="hs-string"
	>&quot;list&quot;</span
	></span
      ><span
      >
</span
      ><span id="line-87"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Schema referencedTypes -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#requiredField"
	><span class="hs-identifier hs-var"
	  >requiredField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;items&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Schema referencedTypes
</span
	><a href="#local-6989586621679922880"
	><span class="hs-identifier hs-var"
	  >itemSchema</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-88"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe Natural -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;minItems&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Natural
</span
	><a href="#local-6989586621679922881"
	><span class="hs-identifier hs-var"
	  >minItems</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-89"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe Natural -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;maxItems&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Natural
</span
	><a href="#local-6989586621679922882"
	><span class="hs-identifier hs-var"
	  >maxItems</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-90"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe Bool -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;uniqueItems&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Bool
</span
	><a href="#local-6989586621679922883"
	><span class="hs-identifier hs-var"
	  >uniqueItems</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-91"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Value) -&gt; Value
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      >
</span
      ><span id="line-92"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaMap"
	><span class="hs-identifier hs-type"
	  >SchemaMap</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922888"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922888"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#MkMapSchema"
	><span class="hs-identifier hs-type"
	  >MkMapSchema</span
	  ></a
	></span
      ><span class="hs-special"
      >{</span
      ><span id="local-6989586621679922890"
      ><span id="local-6989586621679922891"
	><span id="local-6989586621679922892"
	  ><span id="local-6989586621679922893"
	    ><span class="annot"
	      ><span class="annottext"
		>Maybe Natural
Schema referencedTypes
keySchema :: Schema referencedTypes
valueSchema :: Schema referencedTypes
minItems :: Maybe Natural
maxItems :: Maybe Natural
$sel:keySchema:MkMapSchema :: forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; Schema referencedTypes
$sel:valueSchema:MkMapSchema :: forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; Schema referencedTypes
$sel:minItems:MkMapSchema :: forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; Maybe Natural
$sel:maxItems:MkMapSchema :: forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; Maybe Natural
</span
		><a href="#local-6989586621679922890"
		><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
		  >..</span
		  ></a
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >}</span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-93"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; String -&gt; Object
</span
	><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-var"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922888"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><span class="hs-string"
	>&quot;map&quot;</span
	></span
      ><span
      >
</span
      ><span id="line-94"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Schema referencedTypes -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#requiredField"
	><span class="hs-identifier hs-var"
	  >requiredField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;keys&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Schema referencedTypes
</span
	><a href="#local-6989586621679922890"
	><span class="hs-identifier hs-var"
	  >keySchema</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-95"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Schema referencedTypes -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#requiredField"
	><span class="hs-identifier hs-var"
	  >requiredField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;values&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Schema referencedTypes
</span
	><a href="#local-6989586621679922891"
	><span class="hs-identifier hs-var"
	  >valueSchema</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-96"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe Natural -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;minItems&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Natural
</span
	><a href="#local-6989586621679922892"
	><span class="hs-identifier hs-var"
	  >minItems</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-97"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe Natural -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;maxItems&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Natural
</span
	><a href="#local-6989586621679922893"
	><span class="hs-identifier hs-var"
	  >maxItems</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-98"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Value) -&gt; Value
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      >
</span
      ><span id="line-99"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaConstructor"
	><span class="hs-identifier hs-type"
	  >SchemaConstructor</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922898"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922898"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#MkConstructorSchema"
	><span class="hs-identifier hs-type"
	  >MkConstructorSchema</span
	  ></a
	></span
      ><span class="hs-special"
      >{</span
      ><span id="local-6989586621679922900"
      ><span id="local-6989586621679922901"
	><span class="annot"
	  ><span class="annottext"
	    >Natural
[Schema referencedTypes]
index :: Natural
fieldSchemas :: [Schema referencedTypes]
$sel:index:MkConstructorSchema :: forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes -&gt; Natural
$sel:fieldSchemas:MkConstructorSchema :: forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes -&gt; [Schema referencedTypes]
</span
	    ><a href="#local-6989586621679922900"
	    ><span class="hs-glyph hs-var hs-var hs-var hs-var"
	      >..</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >}</span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-100"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; String -&gt; Object
</span
	><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-var"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922898"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><span class="hs-string"
	>&quot;constructor&quot;</span
	></span
      ><span
      >
</span
      ><span id="line-101"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Natural -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#requiredField"
	><span class="hs-identifier hs-var"
	  >requiredField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;index&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Natural
</span
	><a href="#local-6989586621679922900"
	><span class="hs-identifier hs-var"
	  >index</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-102"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; [Schema referencedTypes] -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#requiredField"
	><span class="hs-identifier hs-var"
	  >requiredField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;fields&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>[Schema referencedTypes]
</span
	><a href="#local-6989586621679922901"
	><span class="hs-identifier hs-var"
	  >fieldSchemas</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-103"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Value) -&gt; Value
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      >
</span
      ><span id="line-104"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInData"
	><span class="hs-identifier hs-type"
	  >SchemaBuiltInData</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922904"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922904"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-105"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(Object -&gt; Value) -&gt; Object -&gt; Value
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#%24"
	><span class="hs-operator hs-var"
	  >$</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; Object
</span
	><a href="#local-6989586621679922905"
	><span class="hs-identifier hs-var"
	  >infoFields</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922904"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-106"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInUnit"
	><span class="hs-identifier hs-type"
	  >SchemaBuiltInUnit</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922906"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922906"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-107"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(Object -&gt; Value) -&gt; Object -&gt; Value
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#%24"
	><span class="hs-operator hs-var"
	  >$</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; String -&gt; Object
</span
	><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-var"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922906"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><span class="hs-string"
	>&quot;#unit&quot;</span
	></span
      ><span
      >
</span
      ><span id="line-108"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInBoolean"
	><span class="hs-identifier hs-type"
	  >SchemaBuiltInBoolean</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922907"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922907"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-109"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(Object -&gt; Value) -&gt; Object -&gt; Value
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#%24"
	><span class="hs-operator hs-var"
	  >$</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; String -&gt; Object
</span
	><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-var"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922907"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><span class="hs-string"
	>&quot;#boolean&quot;</span
	></span
      ><span
      >
</span
      ><span id="line-110"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInInteger"
	><span class="hs-identifier hs-type"
	  >SchemaBuiltInInteger</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922908"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922908"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-111"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(Object -&gt; Value) -&gt; Object -&gt; Value
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#%24"
	><span class="hs-operator hs-var"
	  >$</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; String -&gt; Object
</span
	><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-var"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922908"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><span class="hs-string"
	>&quot;#integer&quot;</span
	></span
      ><span
      >
</span
      ><span id="line-112"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInBytes"
	><span class="hs-identifier hs-type"
	  >SchemaBuiltInBytes</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922909"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922909"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-113"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(Object -&gt; Value) -&gt; Object -&gt; Value
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#%24"
	><span class="hs-operator hs-var"
	  >$</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; String -&gt; Object
</span
	><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-var"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922909"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><span class="hs-string"
	>&quot;#bytes&quot;</span
	></span
      ><span
      >
</span
      ><span id="line-114"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInString"
	><span class="hs-identifier hs-type"
	  >SchemaBuiltInString</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922910"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922910"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-115"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(Object -&gt; Value) -&gt; Object -&gt; Value
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#%24"
	><span class="hs-operator hs-var"
	  >$</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; String -&gt; Object
</span
	><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-var"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922910"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><span class="hs-string"
	>&quot;#string&quot;</span
	></span
      ><span
      >
</span
      ><span id="line-116"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInPair"
	><span class="hs-identifier hs-type"
	  >SchemaBuiltInPair</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922911"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922911"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#MkPairSchema"
	><span class="hs-identifier hs-type"
	  >MkPairSchema</span
	  ></a
	></span
      ><span class="hs-special"
      >{</span
      ><span id="local-6989586621679922913"
      ><span class="annot"
	><span class="annottext"
	  >Schema referencedTypes
left :: Schema referencedTypes
$sel:left:MkPairSchema :: forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; Schema referencedTypes
</span
	  ><a href="#local-6989586621679922913"
	  ><span class="hs-identifier hs-var hs-var"
	    >left</span
	    ></a
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679922915"
      ><span class="annot"
	><span class="annottext"
	  >Schema referencedTypes
right :: Schema referencedTypes
$sel:right:MkPairSchema :: forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; Schema referencedTypes
</span
	  ><a href="#local-6989586621679922915"
	  ><span class="hs-identifier hs-var hs-var"
	    >right</span
	    ></a
	  ></span
	></span
      ><span class="hs-special"
      >}</span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-117"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; String -&gt; Object
</span
	><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-var"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922911"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><span class="hs-string"
	>&quot;#pair&quot;</span
	></span
      ><span
      >
</span
      ><span id="line-118"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Schema referencedTypes -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#requiredField"
	><span class="hs-identifier hs-var"
	  >requiredField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;left&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Schema referencedTypes
</span
	><a href="#local-6989586621679922913"
	><span class="hs-identifier hs-var"
	  >left</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-119"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Schema referencedTypes -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#requiredField"
	><span class="hs-identifier hs-var"
	  >requiredField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;right&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Schema referencedTypes
</span
	><a href="#local-6989586621679922915"
	><span class="hs-identifier hs-var"
	  >right</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-120"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Value) -&gt; Value
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      >
</span
      ><span id="line-121"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaBuiltInList"
	><span class="hs-identifier hs-type"
	  >SchemaBuiltInList</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922917"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922917"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span id="local-6989586621679922918"
      ><span class="annot"
	><span class="annottext"
	  >Schema referencedTypes
</span
	  ><a href="#local-6989586621679922918"
	  ><span class="hs-identifier hs-var"
	    >schema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-122"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; String -&gt; Object
</span
	><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-var"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922917"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><span class="hs-string"
	>&quot;#list&quot;</span
	></span
      ><span
      >
</span
      ><span id="line-123"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Schema referencedTypes -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#requiredField"
	><span class="hs-identifier hs-var"
	  >requiredField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;items&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Schema referencedTypes
</span
	><a href="#local-6989586621679922918"
	><span class="hs-identifier hs-var"
	  >schema</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-124"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Value) -&gt; Value
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.Object</span
	></span
      ><span
      >
</span
      ><span id="line-125"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaOneOf"
	><span class="hs-identifier hs-type"
	  >SchemaOneOf</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922919"
      ><span class="annot"
	><span class="annottext"
	  >NonEmpty (Schema referencedTypes)
</span
	  ><a href="#local-6989586621679922919"
	  ><span class="hs-identifier hs-var"
	    >schemas</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-126"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>[Pair] -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.object</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;oneOf&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; NonEmpty (Schema referencedTypes) -&gt; Pair
forall v. ToJSON v =&gt; Key -&gt; v -&gt; Pair
forall e kv v. (KeyValue e kv, ToJSON v) =&gt; Key -&gt; v -&gt; kv
</span
	><span class="hs-operator hs-var"
	>.=</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>NonEmpty (Schema referencedTypes)
</span
	><a href="#local-6989586621679922919"
	><span class="hs-identifier hs-var"
	  >schemas</span
	  ></a
	></span
      ><span class="hs-special"
      >]</span
      ><span
      >
</span
      ><span id="line-127"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaAnyOf"
	><span class="hs-identifier hs-type"
	  >SchemaAnyOf</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922921"
      ><span class="annot"
	><span class="annottext"
	  >NonEmpty (Schema referencedTypes)
</span
	  ><a href="#local-6989586621679922921"
	  ><span class="hs-identifier hs-var"
	    >schemas</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-128"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>[Pair] -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.object</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;anyOf&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; NonEmpty (Schema referencedTypes) -&gt; Pair
forall v. ToJSON v =&gt; Key -&gt; v -&gt; Pair
forall e kv v. (KeyValue e kv, ToJSON v) =&gt; Key -&gt; v -&gt; kv
</span
	><span class="hs-operator hs-var"
	>.=</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>NonEmpty (Schema referencedTypes)
</span
	><a href="#local-6989586621679922921"
	><span class="hs-identifier hs-var"
	  >schemas</span
	  ></a
	></span
      ><span class="hs-special"
      >]</span
      ><span
      >
</span
      ><span id="line-129"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaAllOf"
	><span class="hs-identifier hs-type"
	  >SchemaAllOf</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922922"
      ><span class="annot"
	><span class="annottext"
	  >NonEmpty (Schema referencedTypes)
</span
	  ><a href="#local-6989586621679922922"
	  ><span class="hs-identifier hs-var"
	    >schemas</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-130"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>[Pair] -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.object</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;allOf&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; NonEmpty (Schema referencedTypes) -&gt; Pair
forall v. ToJSON v =&gt; Key -&gt; v -&gt; Pair
forall e kv v. (KeyValue e kv, ToJSON v) =&gt; Key -&gt; v -&gt; kv
</span
	><span class="hs-operator hs-var"
	>.=</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>NonEmpty (Schema referencedTypes)
</span
	><a href="#local-6989586621679922922"
	><span class="hs-identifier hs-var"
	  >schemas</span
	  ></a
	></span
      ><span class="hs-special"
      >]</span
      ><span
      >
</span
      ><span id="line-131"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaNot"
	><span class="hs-identifier hs-type"
	  >SchemaNot</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922923"
      ><span class="annot"
	><span class="annottext"
	  >Schema referencedTypes
</span
	  ><a href="#local-6989586621679922923"
	  ><span class="hs-identifier hs-var"
	    >schema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-132"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>[Pair] -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.object</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;not&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Schema referencedTypes -&gt; Pair
forall v. ToJSON v =&gt; Key -&gt; v -&gt; Pair
forall e kv v. (KeyValue e kv, ToJSON v) =&gt; Key -&gt; v -&gt; kv
</span
	><span class="hs-operator hs-var"
	>.=</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Schema referencedTypes
</span
	><a href="#local-6989586621679922923"
	><span class="hs-identifier hs-var"
	  >schema</span
	  ></a
	></span
      ><span class="hs-special"
      >]</span
      ><span
      >
</span
      ><span id="line-133"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#SchemaDefinitionRef"
	><span class="hs-identifier hs-type"
	  >SchemaDefinitionRef</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621679922924"
      ><span class="annot"
	><span class="annottext"
	  >DefinitionId
</span
	  ><a href="#local-6989586621679922924"
	  ><span class="hs-identifier hs-var"
	    >definitionId</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      >
</span
      ><span id="line-134"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>[Pair] -&gt; Value
</span
	><span class="hs-identifier hs-var"
	>Aeson.object</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;$ref&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Text -&gt; Pair
forall v. ToJSON v =&gt; Key -&gt; v -&gt; Pair
forall e kv v. (KeyValue e kv, ToJSON v) =&gt; Key -&gt; v -&gt; kv
</span
	><span class="hs-operator hs-var"
	>.=</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><span class="annottext"
	>Text
</span
	><span class="hs-string"
	>&quot;#/definitions/&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Text -&gt; Text -&gt; Text
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#%3C%3E"
	><span class="hs-operator hs-var"
	  >&lt;&gt;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>DefinitionId -&gt; Text
</span
	><a href="PlutusTx.Blueprint.Definition.Id.html#definitionIdToText"
	><span class="hs-identifier hs-var"
	  >definitionIdToText</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>DefinitionId
</span
	><a href="#local-6989586621679922924"
	><span class="hs-identifier hs-var"
	  >definitionId</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span class="hs-special"
      >]</span
      ><span
      >
</span
      ><span id="line-135"
      ></span
      ><span
      >   </span
      ><span class="hs-keyword"
      >where</span
      ><span
      >
</span
      ><span id="line-136"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="#local-6989586621679922863"
	><span class="hs-identifier hs-type"
	  >dataType</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#String"
	><span class="hs-identifier hs-type"
	  >String</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier hs-type"
	>Aeson.Object</span
	></span
      ><span
      >
</span
      ><span id="line-137"
      ></span
      ><span
      >    </span
      ><span id="local-6989586621679922863"
      ><span class="annot"
	><span class="annottext"
	  >dataType :: SchemaInfo -&gt; String -&gt; Object
</span
	  ><a href="#local-6989586621679922863"
	  ><span class="hs-identifier hs-var hs-var"
	    >dataType</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span id="local-6989586621679922925"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922925"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span id="local-6989586621679922926"
      ><span class="annot"
	><span class="annottext"
	  >String
</span
	  ><a href="#local-6989586621679922926"
	  ><span class="hs-identifier hs-var"
	    >ty</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; String -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#requiredField"
	><span class="hs-identifier hs-var"
	  >requiredField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;dataType&quot;</span
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String
</span
	><a href="#local-6989586621679922926"
	><span class="hs-identifier hs-var"
	  >ty</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; Object
</span
	><a href="#local-6989586621679922905"
	><span class="hs-identifier hs-var"
	  >infoFields</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922925"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-138"
      ></span
      ><span
      >
</span
      ><span id="line-139"
      ></span
      ><span
      >    </span
      ><span class="annot"
      ><a href="#local-6989586621679922905"
	><span class="hs-identifier hs-type"
	  >infoFields</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.Annotation.html#SchemaInfo"
	><span class="hs-identifier hs-type"
	  >SchemaInfo</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier hs-type"
	>Aeson.Object</span
	></span
      ><span
      >
</span
      ><span id="line-140"
      ></span
      ><span
      >    </span
      ><span id="local-6989586621679922905"
      ><span class="annot"
	><span class="annottext"
	  >infoFields :: SchemaInfo -&gt; Object
</span
	  ><a href="#local-6989586621679922905"
	  ><span class="hs-identifier hs-var hs-var"
	    >infoFields</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span id="local-6989586621679922927"
      ><span class="annot"
	><span class="annottext"
	  >SchemaInfo
</span
	  ><a href="#local-6989586621679922927"
	  ><span class="hs-identifier hs-var"
	    >info</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      >
</span
      ><span id="line-141"
      ></span
      ><span
      >      </span
      ><span class="annot"
      ><span class="annottext"
	>Object
forall v. KeyMap v
</span
	><span class="hs-identifier hs-var"
	>KeyMap.empty</span
	></span
      ><span
      >
</span
      ><span id="line-142"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe String -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;title&quot;</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; Maybe String
</span
	><a href="PlutusTx.Blueprint.Schema.Annotation.html#title"
	><span class="hs-identifier hs-var"
	  >title</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922927"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-143"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe String -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;description&quot;</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; Maybe String
</span
	><a href="PlutusTx.Blueprint.Schema.Annotation.html#description"
	><span class="hs-identifier hs-var"
	  >description</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922927"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-144"
      ></span
      ><span
      >        </span
      ><span class="annot"
      ><span class="annottext"
	>Object -&gt; (Object -&gt; Object) -&gt; Object
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Function.html#%26"
	><span class="hs-operator hs-var"
	  >&amp;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key -&gt; Maybe String -&gt; Object -&gt; Object
forall a. ToJSON a =&gt; Key -&gt; Maybe a -&gt; Object -&gt; Object
</span
	><a href="Data.Aeson.Extra.html#optionalField"
	><span class="hs-identifier hs-var"
	  >optionalField</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Key
</span
	><span class="hs-string"
	>&quot;$comment&quot;</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo -&gt; Maybe String
</span
	><a href="PlutusTx.Blueprint.Schema.Annotation.html#comment"
	><span class="hs-identifier hs-var"
	  >comment</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>SchemaInfo
</span
	><a href="#local-6989586621679922927"
	><span class="hs-identifier hs-var"
	  >info</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-145"
      ></span
      ><span
      >
</span
      ><span id="line-146"
      ></span
      ><span class="hs-keyword"
      >data</span
      ><span
      > </span
      ><span id="IntegerSchema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#IntegerSchema"
	  ><span class="hs-identifier hs-var"
	    >IntegerSchema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span id="MkIntegerSchema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#MkIntegerSchema"
	  ><span class="hs-identifier hs-var"
	    >MkIntegerSchema</span
	    ></a
	  ></span
	></span
      ><span
      >
</span
      ><span id="line-147"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >{</span
      ><span
      > </span
      ><span id="%24sel%3AmultipleOf%3AMkIntegerSchema"
      ><span class="annot"
	><span class="annottext"
	  >IntegerSchema -&gt; Maybe Integer
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AmultipleOf%3AMkIntegerSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >multipleOf</span
	    ></a
	  ></span
	></span
      ><span
      >       </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Maybe"
	><span class="hs-identifier hs-type"
	  >Maybe</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Integer.html#Integer"
	><span class="hs-identifier hs-type"
	  >Integer</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-148"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ An instance is valid if division by this value results in an integer.</span
	></span
      ><span
      >
</span
      ><span id="line-149"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3Aminimum%3AMkIntegerSchema"
      ><span class="annot"
	><span class="annottext"
	  >IntegerSchema -&gt; Maybe Integer
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3Aminimum%3AMkIntegerSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >minimum</span
	    ></a
	  ></span
	></span
      ><span
      >          </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Maybe"
	><span class="hs-identifier hs-type"
	  >Maybe</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Integer.html#Integer"
	><span class="hs-identifier hs-type"
	  >Integer</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-150"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ An instance is valid only if it is greater than or exactly equal to &quot;minimum&quot;.</span
	></span
      ><span
      >
</span
      ><span id="line-151"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3Amaximum%3AMkIntegerSchema"
      ><span class="annot"
	><span class="annottext"
	  >IntegerSchema -&gt; Maybe Integer
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3Amaximum%3AMkIntegerSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >maximum</span
	    ></a
	  ></span
	></span
      ><span
      >          </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Maybe"
	><span class="hs-identifier hs-type"
	  >Maybe</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Integer.html#Integer"
	><span class="hs-identifier hs-type"
	  >Integer</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-152"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ An instance is valid only if it is less than or exactly equal to &quot;maximum&quot;.</span
	></span
      ><span
      >
</span
      ><span id="line-153"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3AexclusiveMinimum%3AMkIntegerSchema"
      ><span class="annot"
	><span class="annottext"
	  >IntegerSchema -&gt; Maybe Integer
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AexclusiveMinimum%3AMkIntegerSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >exclusiveMinimum</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Maybe"
	><span class="hs-identifier hs-type"
	  >Maybe</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Integer.html#Integer"
	><span class="hs-identifier hs-type"
	  >Integer</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-154"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ An instance is valid only if it is strictly greater than &quot;exclusiveMinimum&quot;.</span
	></span
      ><span
      >
</span
      ><span id="line-155"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3AexclusiveMaximum%3AMkIntegerSchema"
      ><span class="annot"
	><span class="annottext"
	  >IntegerSchema -&gt; Maybe Integer
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AexclusiveMaximum%3AMkIntegerSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >exclusiveMaximum</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Maybe"
	><span class="hs-identifier hs-type"
	  >Maybe</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Integer.html#Integer"
	><span class="hs-identifier hs-type"
	  >Integer</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-156"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ An instance is valid only if it is strictly less than &quot;exclusiveMaximum&quot;.</span
	></span
      ><span
      >
</span
      ><span id="line-157"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >}</span
      ><span
      >
</span
      ><span id="line-158"
      ></span
      ><span
      >  </span
      ><span class="hs-keyword"
      >deriving</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-keyword"
	>stock</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span id="local-6989586621679922930"
      ><span id="local-6989586621679922939"
	><span class="annot"
	  ><span class="annottext"
	    >IntegerSchema -&gt; IntegerSchema -&gt; Bool
(IntegerSchema -&gt; IntegerSchema -&gt; Bool)
-&gt; (IntegerSchema -&gt; IntegerSchema -&gt; Bool) -&gt; Eq IntegerSchema
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: IntegerSchema -&gt; IntegerSchema -&gt; Bool
== :: IntegerSchema -&gt; IntegerSchema -&gt; Bool
$c/= :: IntegerSchema -&gt; IntegerSchema -&gt; Bool
/= :: IntegerSchema -&gt; IntegerSchema -&gt; Bool
</span
	    ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Eq"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Eq</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679922945"
      ><span id="local-6989586621679922954"
	><span id="local-6989586621679922962"
	  ><span id="local-6989586621679922965"
	    ><span id="local-6989586621679922968"
	      ><span id="local-6989586621679922971"
		><span id="local-6989586621679922974"
		  ><span class="annot"
		    ><span class="annottext"
		      >Eq IntegerSchema
Eq IntegerSchema =&gt;
(IntegerSchema -&gt; IntegerSchema -&gt; Ordering)
-&gt; (IntegerSchema -&gt; IntegerSchema -&gt; Bool)
-&gt; (IntegerSchema -&gt; IntegerSchema -&gt; Bool)
-&gt; (IntegerSchema -&gt; IntegerSchema -&gt; Bool)
-&gt; (IntegerSchema -&gt; IntegerSchema -&gt; Bool)
-&gt; (IntegerSchema -&gt; IntegerSchema -&gt; IntegerSchema)
-&gt; (IntegerSchema -&gt; IntegerSchema -&gt; IntegerSchema)
-&gt; Ord IntegerSchema
IntegerSchema -&gt; IntegerSchema -&gt; Bool
IntegerSchema -&gt; IntegerSchema -&gt; Ordering
IntegerSchema -&gt; IntegerSchema -&gt; IntegerSchema
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: IntegerSchema -&gt; IntegerSchema -&gt; Ordering
compare :: IntegerSchema -&gt; IntegerSchema -&gt; Ordering
$c&lt; :: IntegerSchema -&gt; IntegerSchema -&gt; Bool
&lt; :: IntegerSchema -&gt; IntegerSchema -&gt; Bool
$c&lt;= :: IntegerSchema -&gt; IntegerSchema -&gt; Bool
&lt;= :: IntegerSchema -&gt; IntegerSchema -&gt; Bool
$c&gt; :: IntegerSchema -&gt; IntegerSchema -&gt; Bool
&gt; :: IntegerSchema -&gt; IntegerSchema -&gt; Bool
$c&gt;= :: IntegerSchema -&gt; IntegerSchema -&gt; Bool
&gt;= :: IntegerSchema -&gt; IntegerSchema -&gt; Bool
$cmax :: IntegerSchema -&gt; IntegerSchema -&gt; IntegerSchema
max :: IntegerSchema -&gt; IntegerSchema -&gt; IntegerSchema
$cmin :: IntegerSchema -&gt; IntegerSchema -&gt; IntegerSchema
min :: IntegerSchema -&gt; IntegerSchema -&gt; IntegerSchema
</span
		      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Ord"
		      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
			>Ord</span
			></a
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679922978"
      ><span id="local-6989586621679922988"
	><span id="local-6989586621679922991"
	  ><span class="annot"
	    ><span class="annottext"
	      >Int -&gt; IntegerSchema -&gt; ShowS
[IntegerSchema] -&gt; ShowS
IntegerSchema -&gt; String
(Int -&gt; IntegerSchema -&gt; ShowS)
-&gt; (IntegerSchema -&gt; String)
-&gt; ([IntegerSchema] -&gt; ShowS)
-&gt; Show IntegerSchema
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; IntegerSchema -&gt; ShowS
showsPrec :: Int -&gt; IntegerSchema -&gt; ShowS
$cshow :: IntegerSchema -&gt; String
show :: IntegerSchema -&gt; String
$cshowList :: [IntegerSchema] -&gt; ShowS
showList :: [IntegerSchema] -&gt; ShowS
</span
	      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Show.html#Show"
	      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
		>Show</span
		></a
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679922995"
      ><span id="local-6989586621679922997"
	><span class="annot"
	  ><span class="annottext"
	    >(forall x. IntegerSchema -&gt; Rep IntegerSchema x)
-&gt; (forall x. Rep IntegerSchema x -&gt; IntegerSchema)
-&gt; Generic IntegerSchema
forall x. Rep IntegerSchema x -&gt; IntegerSchema
forall x. IntegerSchema -&gt; Rep IntegerSchema x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. IntegerSchema -&gt; Rep IntegerSchema x
from :: forall x. IntegerSchema -&gt; Rep IntegerSchema x
$cto :: forall x. Rep IntegerSchema x -&gt; IntegerSchema
to :: forall x. Rep IntegerSchema x -&gt; IntegerSchema
</span
	    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Generics.html#Generic"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Generic</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923002"
      ><span id="local-6989586621679923011"
	><span id="local-6989586621679923019"
	  ><span id="local-6989586621679923021"
	    ><span id="local-6989586621679923023"
	      ><span id="local-6989586621679923028"
		><span id="local-6989586621679923033"
		  ><span id="local-6989586621679923036"
		    ><span id="local-6989586621679923039"
		      ><span id="local-6989586621679923042"
			><span id="local-6989586621679923045"
			  ><span id="local-6989586621679923048"
			    ><span id="local-6989586621679923053"
			      ><span id="local-6989586621679923058"
				><span class="annot"
				  ><span class="annottext"
				    >Typeable IntegerSchema
Typeable IntegerSchema =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; IntegerSchema -&gt; c IntegerSchema)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c IntegerSchema)
-&gt; (IntegerSchema -&gt; Constr)
-&gt; (IntegerSchema -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c IntegerSchema))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c IntegerSchema))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; IntegerSchema -&gt; IntegerSchema)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IntegerSchema -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IntegerSchema -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; IntegerSchema -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; IntegerSchema -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; IntegerSchema -&gt; m IntegerSchema)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; IntegerSchema -&gt; m IntegerSchema)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; IntegerSchema -&gt; m IntegerSchema)
-&gt; Data IntegerSchema
IntegerSchema -&gt; Constr
IntegerSchema -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; IntegerSchema -&gt; IntegerSchema
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; IntegerSchema -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; IntegerSchema -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IntegerSchema -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IntegerSchema -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IntegerSchema -&gt; m IntegerSchema
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IntegerSchema -&gt; m IntegerSchema
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c IntegerSchema
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; IntegerSchema -&gt; c IntegerSchema
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c IntegerSchema)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c IntegerSchema)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; IntegerSchema -&gt; c IntegerSchema
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; IntegerSchema -&gt; c IntegerSchema
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c IntegerSchema
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c IntegerSchema
$ctoConstr :: IntegerSchema -&gt; Constr
toConstr :: IntegerSchema -&gt; Constr
$cdataTypeOf :: IntegerSchema -&gt; DataType
dataTypeOf :: IntegerSchema -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c IntegerSchema)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c IntegerSchema)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c IntegerSchema)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c IntegerSchema)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; IntegerSchema -&gt; IntegerSchema
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; IntegerSchema -&gt; IntegerSchema
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IntegerSchema -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IntegerSchema -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IntegerSchema -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IntegerSchema -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; IntegerSchema -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; IntegerSchema -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; IntegerSchema -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; IntegerSchema -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IntegerSchema -&gt; m IntegerSchema
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IntegerSchema -&gt; m IntegerSchema
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IntegerSchema -&gt; m IntegerSchema
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IntegerSchema -&gt; m IntegerSchema
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IntegerSchema -&gt; m IntegerSchema
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IntegerSchema -&gt; m IntegerSchema
</span
				    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Data.html#Data"
				    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
				      >Data</span
				      ></a
				    ></span
				  ></span
				></span
			      ></span
			    ></span
			  ></span
			></span
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-159"
      ></span
      ><span
      >
</span
      ><span id="line-160"
      ></span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#emptyIntegerSchema"
	><span class="hs-identifier hs-type"
	  >emptyIntegerSchema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#IntegerSchema"
	><span class="hs-identifier hs-type"
	  >IntegerSchema</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-161"
      ></span
      ><span id="emptyIntegerSchema"
      ><span class="annot"
	><span class="annottext"
	  >emptyIntegerSchema :: IntegerSchema
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#emptyIntegerSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >emptyIntegerSchema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      >
</span
      ><span id="line-162"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#MkIntegerSchema"
	><span class="hs-identifier hs-type"
	  >MkIntegerSchema</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-163"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >{</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>$sel:multipleOf:MkIntegerSchema :: Maybe Integer
</span
	><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AmultipleOf%3AMkIntegerSchema"
	><span class="hs-identifier hs-var"
	  >multipleOf</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Integer
forall a. Maybe a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Nothing"
	><span class="hs-identifier hs-var"
	  >Nothing</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-164"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>$sel:minimum:MkIntegerSchema :: Maybe Integer
</span
	><a href="PlutusTx.Blueprint.Schema.html#%24sel%3Aminimum%3AMkIntegerSchema"
	><span class="hs-identifier hs-var"
	  >minimum</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Integer
forall a. Maybe a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Nothing"
	><span class="hs-identifier hs-var"
	  >Nothing</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-165"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>$sel:maximum:MkIntegerSchema :: Maybe Integer
</span
	><a href="PlutusTx.Blueprint.Schema.html#%24sel%3Amaximum%3AMkIntegerSchema"
	><span class="hs-identifier hs-var"
	  >maximum</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Integer
forall a. Maybe a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Nothing"
	><span class="hs-identifier hs-var"
	  >Nothing</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-166"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>$sel:exclusiveMinimum:MkIntegerSchema :: Maybe Integer
</span
	><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AexclusiveMinimum%3AMkIntegerSchema"
	><span class="hs-identifier hs-var"
	  >exclusiveMinimum</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Integer
forall a. Maybe a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Nothing"
	><span class="hs-identifier hs-var"
	  >Nothing</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-167"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>$sel:exclusiveMaximum:MkIntegerSchema :: Maybe Integer
</span
	><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AexclusiveMaximum%3AMkIntegerSchema"
	><span class="hs-identifier hs-var"
	  >exclusiveMaximum</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Integer
forall a. Maybe a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Nothing"
	><span class="hs-identifier hs-var"
	  >Nothing</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-168"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >}</span
      ><span
      >
</span
      ><span id="line-169"
      ></span
      ><span
      >
</span
      ><span id="line-170"
      ></span
      ><span class="hs-keyword"
      >data</span
      ><span
      > </span
      ><span id="BytesSchema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#BytesSchema"
	  ><span class="hs-identifier hs-var"
	    >BytesSchema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span id="MkBytesSchema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#MkBytesSchema"
	  ><span class="hs-identifier hs-var"
	    >MkBytesSchema</span
	    ></a
	  ></span
	></span
      ><span
      >
</span
      ><span id="line-171"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >{</span
      ><span
      > </span
      ><span id="%24sel%3Aenum%3AMkBytesSchema"
      ><span class="annot"
	><span class="annottext"
	  >BytesSchema -&gt; [ByteString]
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3Aenum%3AMkBytesSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >enum</span
	    ></a
	  ></span
	></span
      ><span
      >      </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="annot"
      ><span class="hs-identifier hs-type"
	>ByteString</span
	></span
      ><span class="hs-special"
      >]</span
      ><span
      >
</span
      ><span id="line-172"
      ></span
      ><span
      >  </span
      ><span class="hs-comment"
      >-- ^ An instance validates successfully if once hex-encoded,</span
      ><span
      >
</span
      ><span id="line-173"
      ></span
      ><span
      >  </span
      ><span class="hs-comment"
      >-- its value matches one of the specified values.</span
      ><span
      >
</span
      ><span id="line-174"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3AminLength%3AMkBytesSchema"
      ><span class="annot"
	><span class="annottext"
	  >BytesSchema -&gt; Maybe Natural
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AminLength%3AMkBytesSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >minLength</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Maybe"
	><span class="hs-identifier hs-type"
	  >Maybe</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Natural.html#Natural"
	><span class="hs-identifier hs-type"
	  >Natural</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-175"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ An instance is valid if its length is greater than, or equal to, this value.</span
	></span
      ><span
      >
</span
      ><span id="line-176"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3AmaxLength%3AMkBytesSchema"
      ><span class="annot"
	><span class="annottext"
	  >BytesSchema -&gt; Maybe Natural
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AmaxLength%3AMkBytesSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >maxLength</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Maybe"
	><span class="hs-identifier hs-type"
	  >Maybe</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Natural.html#Natural"
	><span class="hs-identifier hs-type"
	  >Natural</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-177"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ An instance is valid if its length is less than, or equal to, this value.</span
	></span
      ><span
      >
</span
      ><span id="line-178"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >}</span
      ><span
      >
</span
      ><span id="line-179"
      ></span
      ><span
      >  </span
      ><span class="hs-keyword"
      >deriving</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-keyword"
	>stock</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span id="local-6989586621679923065"
      ><span id="local-6989586621679923073"
	><span class="annot"
	  ><span class="annottext"
	    >BytesSchema -&gt; BytesSchema -&gt; Bool
(BytesSchema -&gt; BytesSchema -&gt; Bool)
-&gt; (BytesSchema -&gt; BytesSchema -&gt; Bool) -&gt; Eq BytesSchema
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: BytesSchema -&gt; BytesSchema -&gt; Bool
== :: BytesSchema -&gt; BytesSchema -&gt; Bool
$c/= :: BytesSchema -&gt; BytesSchema -&gt; Bool
/= :: BytesSchema -&gt; BytesSchema -&gt; Bool
</span
	    ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Eq"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Eq</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923080"
      ><span id="local-6989586621679923088"
	><span id="local-6989586621679923095"
	  ><span id="local-6989586621679923098"
	    ><span id="local-6989586621679923101"
	      ><span id="local-6989586621679923104"
		><span id="local-6989586621679923107"
		  ><span class="annot"
		    ><span class="annottext"
		      >Eq BytesSchema
Eq BytesSchema =&gt;
(BytesSchema -&gt; BytesSchema -&gt; Ordering)
-&gt; (BytesSchema -&gt; BytesSchema -&gt; Bool)
-&gt; (BytesSchema -&gt; BytesSchema -&gt; Bool)
-&gt; (BytesSchema -&gt; BytesSchema -&gt; Bool)
-&gt; (BytesSchema -&gt; BytesSchema -&gt; Bool)
-&gt; (BytesSchema -&gt; BytesSchema -&gt; BytesSchema)
-&gt; (BytesSchema -&gt; BytesSchema -&gt; BytesSchema)
-&gt; Ord BytesSchema
BytesSchema -&gt; BytesSchema -&gt; Bool
BytesSchema -&gt; BytesSchema -&gt; Ordering
BytesSchema -&gt; BytesSchema -&gt; BytesSchema
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: BytesSchema -&gt; BytesSchema -&gt; Ordering
compare :: BytesSchema -&gt; BytesSchema -&gt; Ordering
$c&lt; :: BytesSchema -&gt; BytesSchema -&gt; Bool
&lt; :: BytesSchema -&gt; BytesSchema -&gt; Bool
$c&lt;= :: BytesSchema -&gt; BytesSchema -&gt; Bool
&lt;= :: BytesSchema -&gt; BytesSchema -&gt; Bool
$c&gt; :: BytesSchema -&gt; BytesSchema -&gt; Bool
&gt; :: BytesSchema -&gt; BytesSchema -&gt; Bool
$c&gt;= :: BytesSchema -&gt; BytesSchema -&gt; Bool
&gt;= :: BytesSchema -&gt; BytesSchema -&gt; Bool
$cmax :: BytesSchema -&gt; BytesSchema -&gt; BytesSchema
max :: BytesSchema -&gt; BytesSchema -&gt; BytesSchema
$cmin :: BytesSchema -&gt; BytesSchema -&gt; BytesSchema
min :: BytesSchema -&gt; BytesSchema -&gt; BytesSchema
</span
		      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Ord"
		      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
			>Ord</span
			></a
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923112"
      ><span id="local-6989586621679923121"
	><span id="local-6989586621679923124"
	  ><span class="annot"
	    ><span class="annottext"
	      >Int -&gt; BytesSchema -&gt; ShowS
[BytesSchema] -&gt; ShowS
BytesSchema -&gt; String
(Int -&gt; BytesSchema -&gt; ShowS)
-&gt; (BytesSchema -&gt; String)
-&gt; ([BytesSchema] -&gt; ShowS)
-&gt; Show BytesSchema
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; BytesSchema -&gt; ShowS
showsPrec :: Int -&gt; BytesSchema -&gt; ShowS
$cshow :: BytesSchema -&gt; String
show :: BytesSchema -&gt; String
$cshowList :: [BytesSchema] -&gt; ShowS
showList :: [BytesSchema] -&gt; ShowS
</span
	      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Show.html#Show"
	      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
		>Show</span
		></a
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923129"
      ><span id="local-6989586621679923131"
	><span class="annot"
	  ><span class="annottext"
	    >(forall x. BytesSchema -&gt; Rep BytesSchema x)
-&gt; (forall x. Rep BytesSchema x -&gt; BytesSchema)
-&gt; Generic BytesSchema
forall x. Rep BytesSchema x -&gt; BytesSchema
forall x. BytesSchema -&gt; Rep BytesSchema x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. BytesSchema -&gt; Rep BytesSchema x
from :: forall x. BytesSchema -&gt; Rep BytesSchema x
$cto :: forall x. Rep BytesSchema x -&gt; BytesSchema
to :: forall x. Rep BytesSchema x -&gt; BytesSchema
</span
	    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Generics.html#Generic"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Generic</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923136"
      ><span id="local-6989586621679923144"
	><span id="local-6989586621679923151"
	  ><span id="local-6989586621679923153"
	    ><span id="local-6989586621679923155"
	      ><span id="local-6989586621679923160"
		><span id="local-6989586621679923165"
		  ><span id="local-6989586621679923168"
		    ><span id="local-6989586621679923171"
		      ><span id="local-6989586621679923174"
			><span id="local-6989586621679923177"
			  ><span id="local-6989586621679923180"
			    ><span id="local-6989586621679923185"
			      ><span id="local-6989586621679923190"
				><span class="annot"
				  ><span class="annottext"
				    >Typeable BytesSchema
Typeable BytesSchema =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; BytesSchema -&gt; c BytesSchema)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c BytesSchema)
-&gt; (BytesSchema -&gt; Constr)
-&gt; (BytesSchema -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c BytesSchema))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c BytesSchema))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; BytesSchema -&gt; BytesSchema)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BytesSchema -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BytesSchema -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; BytesSchema -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BytesSchema -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; BytesSchema -&gt; m BytesSchema)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; BytesSchema -&gt; m BytesSchema)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; BytesSchema -&gt; m BytesSchema)
-&gt; Data BytesSchema
BytesSchema -&gt; Constr
BytesSchema -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; BytesSchema -&gt; BytesSchema
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BytesSchema -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; BytesSchema -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BytesSchema -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BytesSchema -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BytesSchema -&gt; m BytesSchema
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BytesSchema -&gt; m BytesSchema
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c BytesSchema
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BytesSchema -&gt; c BytesSchema
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c BytesSchema)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c BytesSchema)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BytesSchema -&gt; c BytesSchema
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BytesSchema -&gt; c BytesSchema
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c BytesSchema
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c BytesSchema
$ctoConstr :: BytesSchema -&gt; Constr
toConstr :: BytesSchema -&gt; Constr
$cdataTypeOf :: BytesSchema -&gt; DataType
dataTypeOf :: BytesSchema -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c BytesSchema)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c BytesSchema)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c BytesSchema)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c BytesSchema)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; BytesSchema -&gt; BytesSchema
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; BytesSchema -&gt; BytesSchema
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BytesSchema -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BytesSchema -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BytesSchema -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BytesSchema -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; BytesSchema -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; BytesSchema -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BytesSchema -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BytesSchema -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BytesSchema -&gt; m BytesSchema
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BytesSchema -&gt; m BytesSchema
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BytesSchema -&gt; m BytesSchema
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BytesSchema -&gt; m BytesSchema
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BytesSchema -&gt; m BytesSchema
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BytesSchema -&gt; m BytesSchema
</span
				    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Data.html#Data"
				    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
				      >Data</span
				      ></a
				    ></span
				  ></span
				></span
			      ></span
			    ></span
			  ></span
			></span
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-180"
      ></span
      ><span
      >
</span
      ><span id="line-181"
      ></span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#emptyBytesSchema"
	><span class="hs-identifier hs-type"
	  >emptyBytesSchema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#BytesSchema"
	><span class="hs-identifier hs-type"
	  >BytesSchema</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-182"
      ></span
      ><span id="emptyBytesSchema"
      ><span class="annot"
	><span class="annottext"
	  >emptyBytesSchema :: BytesSchema
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#emptyBytesSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >emptyBytesSchema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#MkBytesSchema"
	><span class="hs-identifier hs-type"
	  >MkBytesSchema</span
	  ></a
	></span
      ><span class="hs-special"
      >{</span
      ><span class="annot"
      ><span class="annottext"
	>$sel:enum:MkBytesSchema :: [ByteString]
</span
	><a href="PlutusTx.Blueprint.Schema.html#%24sel%3Aenum%3AMkBytesSchema"
	><span class="hs-identifier hs-var"
	  >enum</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="hs-special"
      >]</span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>$sel:minLength:MkBytesSchema :: Maybe Natural
</span
	><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AminLength%3AMkBytesSchema"
	><span class="hs-identifier hs-var"
	  >minLength</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Natural
forall a. Maybe a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Nothing"
	><span class="hs-identifier hs-var"
	  >Nothing</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>$sel:maxLength:MkBytesSchema :: Maybe Natural
</span
	><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AmaxLength%3AMkBytesSchema"
	><span class="hs-identifier hs-var"
	  >maxLength</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Natural
forall a. Maybe a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Nothing"
	><span class="hs-identifier hs-var"
	  >Nothing</span
	  ></a
	></span
      ><span class="hs-special"
      >}</span
      ><span
      >
</span
      ><span id="line-183"
      ></span
      ><span
      >
</span
      ><span id="line-184"
      ></span
      ><span class="hs-keyword"
      >data</span
      ><span
      > </span
      ><span id="ListSchema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#ListSchema"
	  ><span class="hs-identifier hs-var"
	    >ListSchema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span id="local-6989586621679922151"
      ><span class="annot"
	><a href="#local-6989586621679922151"
	  ><span class="hs-identifier hs-type"
	    >referencedTypes</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Types.html#Type"
	><span class="hs-identifier hs-type"
	  >Type</span
	  ></a
	></span
      ><span class="hs-special"
      >]</span
      ><span class="hs-special"
      >)</span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span id="MkListSchema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#MkListSchema"
	  ><span class="hs-identifier hs-var"
	    >MkListSchema</span
	    ></a
	  ></span
	></span
      ><span
      >
</span
      ><span id="line-185"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >{</span
      ><span
      > </span
      ><span id="%24sel%3AitemSchema%3AMkListSchema"
      ><span class="annot"
	><span class="annottext"
	  >forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; Schema referencedTypes
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AitemSchema%3AMkListSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >itemSchema</span
	    ></a
	  ></span
	></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#Schema"
	><span class="hs-identifier hs-type"
	  >Schema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922151"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-186"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ Element schema</span
	></span
      ><span
      >
</span
      ><span id="line-187"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3AminItems%3AMkListSchema"
      ><span class="annot"
	><span class="annottext"
	  >forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; Maybe Natural
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AminItems%3AMkListSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >minItems</span
	    ></a
	  ></span
	></span
      ><span
      >    </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Maybe"
	><span class="hs-identifier hs-type"
	  >Maybe</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Natural.html#Natural"
	><span class="hs-identifier hs-type"
	  >Natural</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-188"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ An array instance is valid if its size is greater than, or equal to, this value.</span
	></span
      ><span
      >
</span
      ><span id="line-189"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3AmaxItems%3AMkListSchema"
      ><span class="annot"
	><span class="annottext"
	  >forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; Maybe Natural
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AmaxItems%3AMkListSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >maxItems</span
	    ></a
	  ></span
	></span
      ><span
      >    </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Maybe"
	><span class="hs-identifier hs-type"
	  >Maybe</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Natural.html#Natural"
	><span class="hs-identifier hs-type"
	  >Natural</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-190"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ An array instance is valid if its size is less than, or equal to, this value.</span
	></span
      ><span
      >
</span
      ><span id="line-191"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3AuniqueItems%3AMkListSchema"
      ><span class="annot"
	><span class="annottext"
	  >forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; Maybe Bool
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AuniqueItems%3AMkListSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >uniqueItems</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Maybe"
	><span class="hs-identifier hs-type"
	  >Maybe</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Types.html#Bool"
	><span class="hs-identifier hs-type"
	  >Bool</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-192"
      ></span
      ><span
      >  </span
      ><span class="hs-comment"
      >-- ^ If this value is false, the instance validates successfully.</span
      ><span
      >
</span
      ><span id="line-193"
      ></span
      ><span
      >  </span
      ><span class="hs-comment"
      >-- If it is set to True, the instance validates successfully if all of its elements are unique.</span
      ><span
      >
</span
      ><span id="line-194"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >}</span
      ><span
      >
</span
      ><span id="line-195"
      ></span
      ><span
      >  </span
      ><span class="hs-keyword"
      >deriving</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-keyword"
	>stock</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span id="local-6989586621679923198"
      ><span id="local-6989586621679923206"
	><span class="annot"
	  ><span class="annottext"
	    >ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
(ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool)
-&gt; (ListSchema referencedTypes
    -&gt; ListSchema referencedTypes -&gt; Bool)
-&gt; Eq (ListSchema referencedTypes)
forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
== :: ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
$c/= :: forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
/= :: ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
</span
	    ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Eq"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Eq</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923212"
      ><span id="local-6989586621679923220"
	><span id="local-6989586621679923228"
	  ><span id="local-6989586621679923231"
	    ><span id="local-6989586621679923234"
	      ><span id="local-6989586621679923237"
		><span id="local-6989586621679923240"
		  ><span class="annot"
		    ><span class="annottext"
		      >Eq (ListSchema referencedTypes)
Eq (ListSchema referencedTypes) =&gt;
(ListSchema referencedTypes
 -&gt; ListSchema referencedTypes -&gt; Ordering)
-&gt; (ListSchema referencedTypes
    -&gt; ListSchema referencedTypes -&gt; Bool)
-&gt; (ListSchema referencedTypes
    -&gt; ListSchema referencedTypes -&gt; Bool)
-&gt; (ListSchema referencedTypes
    -&gt; ListSchema referencedTypes -&gt; Bool)
-&gt; (ListSchema referencedTypes
    -&gt; ListSchema referencedTypes -&gt; Bool)
-&gt; (ListSchema referencedTypes
    -&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes)
-&gt; (ListSchema referencedTypes
    -&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes)
-&gt; Ord (ListSchema referencedTypes)
ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
ListSchema referencedTypes
-&gt; ListSchema referencedTypes -&gt; Ordering
ListSchema referencedTypes
-&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes
forall (referencedTypes :: [*]). Eq (ListSchema referencedTypes)
forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
forall (referencedTypes :: [*]).
ListSchema referencedTypes
-&gt; ListSchema referencedTypes -&gt; Ordering
forall (referencedTypes :: [*]).
ListSchema referencedTypes
-&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: forall (referencedTypes :: [*]).
ListSchema referencedTypes
-&gt; ListSchema referencedTypes -&gt; Ordering
compare :: ListSchema referencedTypes
-&gt; ListSchema referencedTypes -&gt; Ordering
$c&lt; :: forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
&lt; :: ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
$c&lt;= :: forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
&lt;= :: ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
$c&gt; :: forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
&gt; :: ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
$c&gt;= :: forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
&gt;= :: ListSchema referencedTypes -&gt; ListSchema referencedTypes -&gt; Bool
$cmax :: forall (referencedTypes :: [*]).
ListSchema referencedTypes
-&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes
max :: ListSchema referencedTypes
-&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes
$cmin :: forall (referencedTypes :: [*]).
ListSchema referencedTypes
-&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes
min :: ListSchema referencedTypes
-&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes
</span
		      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Ord"
		      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
			>Ord</span
			></a
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923244"
      ><span id="local-6989586621679923253"
	><span id="local-6989586621679923256"
	  ><span class="annot"
	    ><span class="annottext"
	      >Int -&gt; ListSchema referencedTypes -&gt; ShowS
[ListSchema referencedTypes] -&gt; ShowS
ListSchema referencedTypes -&gt; String
(Int -&gt; ListSchema referencedTypes -&gt; ShowS)
-&gt; (ListSchema referencedTypes -&gt; String)
-&gt; ([ListSchema referencedTypes] -&gt; ShowS)
-&gt; Show (ListSchema referencedTypes)
forall (referencedTypes :: [*]).
Int -&gt; ListSchema referencedTypes -&gt; ShowS
forall (referencedTypes :: [*]).
[ListSchema referencedTypes] -&gt; ShowS
forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: forall (referencedTypes :: [*]).
Int -&gt; ListSchema referencedTypes -&gt; ShowS
showsPrec :: Int -&gt; ListSchema referencedTypes -&gt; ShowS
$cshow :: forall (referencedTypes :: [*]).
ListSchema referencedTypes -&gt; String
show :: ListSchema referencedTypes -&gt; String
$cshowList :: forall (referencedTypes :: [*]).
[ListSchema referencedTypes] -&gt; ShowS
showList :: [ListSchema referencedTypes] -&gt; ShowS
</span
	      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Show.html#Show"
	      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
		>Show</span
		></a
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923260"
      ><span id="local-6989586621679923262"
	><span class="annot"
	  ><span class="annottext"
	    >(forall x.
 ListSchema referencedTypes -&gt; Rep (ListSchema referencedTypes) x)
-&gt; (forall x.
    Rep (ListSchema referencedTypes) x -&gt; ListSchema referencedTypes)
-&gt; Generic (ListSchema referencedTypes)
forall (referencedTypes :: [*]) x.
Rep (ListSchema referencedTypes) x -&gt; ListSchema referencedTypes
forall (referencedTypes :: [*]) x.
ListSchema referencedTypes -&gt; Rep (ListSchema referencedTypes) x
forall x.
Rep (ListSchema referencedTypes) x -&gt; ListSchema referencedTypes
forall x.
ListSchema referencedTypes -&gt; Rep (ListSchema referencedTypes) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall (referencedTypes :: [*]) x.
ListSchema referencedTypes -&gt; Rep (ListSchema referencedTypes) x
from :: forall x.
ListSchema referencedTypes -&gt; Rep (ListSchema referencedTypes) x
$cto :: forall (referencedTypes :: [*]) x.
Rep (ListSchema referencedTypes) x -&gt; ListSchema referencedTypes
to :: forall x.
Rep (ListSchema referencedTypes) x -&gt; ListSchema referencedTypes
</span
	    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Generics.html#Generic"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Generic</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923269"
      ><span id="local-6989586621679923277"
	><span id="local-6989586621679923285"
	  ><span id="local-6989586621679923287"
	    ><span id="local-6989586621679923289"
	      ><span id="local-6989586621679923294"
		><span id="local-6989586621679923299"
		  ><span id="local-6989586621679923302"
		    ><span id="local-6989586621679923305"
		      ><span id="local-6989586621679923308"
			><span id="local-6989586621679923311"
			  ><span id="local-6989586621679923314"
			    ><span id="local-6989586621679923319"
			      ><span id="local-6989586621679923324"
				><span class="annot"
				  ><span class="annottext"
				    >Typeable (ListSchema referencedTypes)
Typeable (ListSchema referencedTypes) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; ListSchema referencedTypes
 -&gt; c (ListSchema referencedTypes))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r)
    -&gt; Constr
    -&gt; c (ListSchema referencedTypes))
-&gt; (ListSchema referencedTypes -&gt; Constr)
-&gt; (ListSchema referencedTypes -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d))
    -&gt; Maybe (c (ListSchema referencedTypes)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (ListSchema referencedTypes)))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r
    -&gt; (forall d. Data d =&gt; d -&gt; r')
    -&gt; ListSchema referencedTypes
    -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r
    -&gt; (forall d. Data d =&gt; d -&gt; r')
    -&gt; ListSchema referencedTypes
    -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; ListSchema referencedTypes -&gt; [u])
-&gt; (forall u.
    Int
    -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ListSchema referencedTypes -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes))
-&gt; Data (ListSchema referencedTypes)
ListSchema referencedTypes -&gt; Constr
ListSchema referencedTypes -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
Typeable (ListSchema referencedTypes)
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
ListSchema referencedTypes -&gt; Constr
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
ListSchema referencedTypes -&gt; DataType
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes
forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ListSchema referencedTypes -&gt; u
forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ListSchema referencedTypes -&gt; [u]
forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ListSchema referencedTypes
-&gt; r
forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ListSchema referencedTypes
-&gt; r
forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes)
forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes)
forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ListSchema referencedTypes)
forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ListSchema referencedTypes
-&gt; c (ListSchema referencedTypes)
forall (referencedTypes :: [*]) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (ListSchema referencedTypes))
forall (referencedTypes :: [*]) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ListSchema referencedTypes))
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ListSchema referencedTypes -&gt; u
forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; ListSchema referencedTypes -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ListSchema referencedTypes
-&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ListSchema referencedTypes
-&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ListSchema referencedTypes)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ListSchema referencedTypes
-&gt; c (ListSchema referencedTypes)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (ListSchema referencedTypes))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ListSchema referencedTypes))
$cgfoldl :: forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ListSchema referencedTypes
-&gt; c (ListSchema referencedTypes)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ListSchema referencedTypes
-&gt; c (ListSchema referencedTypes)
$cgunfold :: forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ListSchema referencedTypes)
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ListSchema referencedTypes)
$ctoConstr :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
ListSchema referencedTypes -&gt; Constr
toConstr :: ListSchema referencedTypes -&gt; Constr
$cdataTypeOf :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
ListSchema referencedTypes -&gt; DataType
dataTypeOf :: ListSchema referencedTypes -&gt; DataType
$cdataCast1 :: forall (referencedTypes :: [*]) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (ListSchema referencedTypes))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (ListSchema referencedTypes))
$cdataCast2 :: forall (referencedTypes :: [*]) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ListSchema referencedTypes))
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ListSchema referencedTypes))
$cgmapT :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; ListSchema referencedTypes -&gt; ListSchema referencedTypes
$cgmapQl :: forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ListSchema referencedTypes
-&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ListSchema referencedTypes
-&gt; r
$cgmapQr :: forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ListSchema referencedTypes
-&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ListSchema referencedTypes
-&gt; r
$cgmapQ :: forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ListSchema referencedTypes -&gt; [u]
gmapQ :: forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; ListSchema referencedTypes -&gt; [u]
$cgmapQi :: forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ListSchema referencedTypes -&gt; u
gmapQi :: forall u.
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ListSchema referencedTypes -&gt; u
$cgmapM :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes)
$cgmapMp :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes)
$cgmapMo :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ListSchema referencedTypes -&gt; m (ListSchema referencedTypes)
</span
				    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Data.html#Data"
				    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
				      >Data</span
				      ></a
				    ></span
				  ></span
				></span
			      ></span
			    ></span
			  ></span
			></span
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-196"
      ></span
      ><span
      >
</span
      ><span id="line-197"
      ></span
      ><span id="local-6989586621679922198"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#mkListSchema"
	  ><span class="hs-identifier hs-type"
	    >mkListSchema</span
	    ></a
	  ></span
	><span
	> </span
	><span class="hs-glyph"
	>::</span
	><span
	> </span
	><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#Schema"
	  ><span class="hs-identifier hs-type"
	    >Schema</span
	    ></a
	  ></span
	><span
	> </span
	><span class="annot"
	><a href="#local-6989586621679922198"
	  ><span class="hs-identifier hs-type"
	    >referencedTypes</span
	    ></a
	  ></span
	><span
	> </span
	><span class="hs-glyph"
	>-&gt;</span
	><span
	> </span
	><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#ListSchema"
	  ><span class="hs-identifier hs-type"
	    >ListSchema</span
	    ></a
	  ></span
	><span
	> </span
	><span class="annot"
	><a href="#local-6989586621679922198"
	  ><span class="hs-identifier hs-type"
	    >referencedTypes</span
	    ></a
	  ></span
	></span
      ><span
      >
</span
      ><span id="line-198"
      ></span
      ><span id="mkListSchema"
      ><span class="annot"
	><span class="annottext"
	  >mkListSchema :: forall (referencedTypes :: [*]).
Schema referencedTypes -&gt; ListSchema referencedTypes
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#mkListSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >mkListSchema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span id="local-6989586621679923330"
      ><span class="annot"
	><span class="annottext"
	  >Schema referencedTypes
</span
	  ><a href="#local-6989586621679923330"
	  ><span class="hs-identifier hs-var"
	    >itemSchema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      >
</span
      ><span id="line-199"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#MkListSchema"
	><span class="hs-identifier hs-type"
	  >MkListSchema</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-200"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >{</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Schema referencedTypes
$sel:itemSchema:MkListSchema :: Schema referencedTypes
itemSchema :: Schema referencedTypes
</span
	><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AitemSchema%3AMkListSchema"
	><span class="hs-identifier hs-var hs-var"
	  >itemSchema</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-201"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>$sel:minItems:MkListSchema :: Maybe Natural
</span
	><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AminItems%3AMkListSchema"
	><span class="hs-identifier hs-var"
	  >minItems</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Natural
forall a. Maybe a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Nothing"
	><span class="hs-identifier hs-var"
	  >Nothing</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-202"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>$sel:maxItems:MkListSchema :: Maybe Natural
</span
	><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AmaxItems%3AMkListSchema"
	><span class="hs-identifier hs-var"
	  >maxItems</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Natural
forall a. Maybe a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Nothing"
	><span class="hs-identifier hs-var"
	  >Nothing</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-203"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>$sel:uniqueItems:MkListSchema :: Maybe Bool
</span
	><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AuniqueItems%3AMkListSchema"
	><span class="hs-identifier hs-var"
	  >uniqueItems</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Maybe Bool
forall a. Maybe a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Nothing"
	><span class="hs-identifier hs-var"
	  >Nothing</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-204"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >}</span
      ><span
      >
</span
      ><span id="line-205"
      ></span
      ><span
      >
</span
      ><span id="line-206"
      ></span
      ><span class="hs-keyword"
      >data</span
      ><span
      > </span
      ><span id="MapSchema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#MapSchema"
	  ><span class="hs-identifier hs-var"
	    >MapSchema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span id="local-6989586621679922153"
      ><span class="annot"
	><a href="#local-6989586621679922153"
	  ><span class="hs-identifier hs-type"
	    >referencedTypes</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Types.html#Type"
	><span class="hs-identifier hs-type"
	  >Type</span
	  ></a
	></span
      ><span class="hs-special"
      >]</span
      ><span class="hs-special"
      >)</span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span id="MkMapSchema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#MkMapSchema"
	  ><span class="hs-identifier hs-var"
	    >MkMapSchema</span
	    ></a
	  ></span
	></span
      ><span
      >
</span
      ><span id="line-207"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >{</span
      ><span
      > </span
      ><span id="%24sel%3AkeySchema%3AMkMapSchema"
      ><span class="annot"
	><span class="annottext"
	  >forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; Schema referencedTypes
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AkeySchema%3AMkMapSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >keySchema</span
	    ></a
	  ></span
	></span
      ><span
      >   </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#Schema"
	><span class="hs-identifier hs-type"
	  >Schema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922153"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-208"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ Key schema</span
	></span
      ><span
      >
</span
      ><span id="line-209"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3AvalueSchema%3AMkMapSchema"
      ><span class="annot"
	><span class="annottext"
	  >forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; Schema referencedTypes
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AvalueSchema%3AMkMapSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >valueSchema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#Schema"
	><span class="hs-identifier hs-type"
	  >Schema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922153"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-210"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ Value schema</span
	></span
      ><span
      >
</span
      ><span id="line-211"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3AminItems%3AMkMapSchema"
      ><span class="annot"
	><span class="annottext"
	  >forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; Maybe Natural
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AminItems%3AMkMapSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >minItems</span
	    ></a
	  ></span
	></span
      ><span
      >    </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Maybe"
	><span class="hs-identifier hs-type"
	  >Maybe</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Natural.html#Natural"
	><span class="hs-identifier hs-type"
	  >Natural</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-212"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ A map instance is valid if its size is greater than, or equal to, this value.</span
	></span
      ><span
      >
</span
      ><span id="line-213"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3AmaxItems%3AMkMapSchema"
      ><span class="annot"
	><span class="annottext"
	  >forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; Maybe Natural
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AmaxItems%3AMkMapSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >maxItems</span
	    ></a
	  ></span
	></span
      ><span
      >    </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Maybe.html#Maybe"
	><span class="hs-identifier hs-type"
	  >Maybe</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Natural.html#Natural"
	><span class="hs-identifier hs-type"
	  >Natural</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-214"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ A map instance is valid if its size is less than, or equal to, this value.</span
	></span
      ><span
      >
</span
      ><span id="line-215"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >}</span
      ><span
      >
</span
      ><span id="line-216"
      ></span
      ><span
      >  </span
      ><span class="hs-keyword"
      >deriving</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-keyword"
	>stock</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span id="local-6989586621679923332"
      ><span id="local-6989586621679923339"
	><span class="annot"
	  ><span class="annottext"
	    >MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
(MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool)
-&gt; (MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool)
-&gt; Eq (MapSchema referencedTypes)
forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
== :: MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
$c/= :: forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
/= :: MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
</span
	    ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Eq"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Eq</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923344"
      ><span id="local-6989586621679923351"
	><span id="local-6989586621679923358"
	  ><span id="local-6989586621679923361"
	    ><span id="local-6989586621679923364"
	      ><span id="local-6989586621679923367"
		><span id="local-6989586621679923370"
		  ><span class="annot"
		    ><span class="annottext"
		      >Eq (MapSchema referencedTypes)
Eq (MapSchema referencedTypes) =&gt;
(MapSchema referencedTypes
 -&gt; MapSchema referencedTypes -&gt; Ordering)
-&gt; (MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool)
-&gt; (MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool)
-&gt; (MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool)
-&gt; (MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool)
-&gt; (MapSchema referencedTypes
    -&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes)
-&gt; (MapSchema referencedTypes
    -&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes)
-&gt; Ord (MapSchema referencedTypes)
MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Ordering
MapSchema referencedTypes
-&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes
forall (referencedTypes :: [*]). Eq (MapSchema referencedTypes)
forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Ordering
forall (referencedTypes :: [*]).
MapSchema referencedTypes
-&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Ordering
compare :: MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Ordering
$c&lt; :: forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
&lt; :: MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
$c&lt;= :: forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
&lt;= :: MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
$c&gt; :: forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
&gt; :: MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
$c&gt;= :: forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
&gt;= :: MapSchema referencedTypes -&gt; MapSchema referencedTypes -&gt; Bool
$cmax :: forall (referencedTypes :: [*]).
MapSchema referencedTypes
-&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes
max :: MapSchema referencedTypes
-&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes
$cmin :: forall (referencedTypes :: [*]).
MapSchema referencedTypes
-&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes
min :: MapSchema referencedTypes
-&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes
</span
		      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Ord"
		      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
			>Ord</span
			></a
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923373"
      ><span id="local-6989586621679923381"
	><span id="local-6989586621679923384"
	  ><span class="annot"
	    ><span class="annottext"
	      >Int -&gt; MapSchema referencedTypes -&gt; ShowS
[MapSchema referencedTypes] -&gt; ShowS
MapSchema referencedTypes -&gt; String
(Int -&gt; MapSchema referencedTypes -&gt; ShowS)
-&gt; (MapSchema referencedTypes -&gt; String)
-&gt; ([MapSchema referencedTypes] -&gt; ShowS)
-&gt; Show (MapSchema referencedTypes)
forall (referencedTypes :: [*]).
Int -&gt; MapSchema referencedTypes -&gt; ShowS
forall (referencedTypes :: [*]).
[MapSchema referencedTypes] -&gt; ShowS
forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: forall (referencedTypes :: [*]).
Int -&gt; MapSchema referencedTypes -&gt; ShowS
showsPrec :: Int -&gt; MapSchema referencedTypes -&gt; ShowS
$cshow :: forall (referencedTypes :: [*]).
MapSchema referencedTypes -&gt; String
show :: MapSchema referencedTypes -&gt; String
$cshowList :: forall (referencedTypes :: [*]).
[MapSchema referencedTypes] -&gt; ShowS
showList :: [MapSchema referencedTypes] -&gt; ShowS
</span
	      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Show.html#Show"
	      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
		>Show</span
		></a
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923387"
      ><span id="local-6989586621679923389"
	><span class="annot"
	  ><span class="annottext"
	    >(forall x.
 MapSchema referencedTypes -&gt; Rep (MapSchema referencedTypes) x)
-&gt; (forall x.
    Rep (MapSchema referencedTypes) x -&gt; MapSchema referencedTypes)
-&gt; Generic (MapSchema referencedTypes)
forall (referencedTypes :: [*]) x.
Rep (MapSchema referencedTypes) x -&gt; MapSchema referencedTypes
forall (referencedTypes :: [*]) x.
MapSchema referencedTypes -&gt; Rep (MapSchema referencedTypes) x
forall x.
Rep (MapSchema referencedTypes) x -&gt; MapSchema referencedTypes
forall x.
MapSchema referencedTypes -&gt; Rep (MapSchema referencedTypes) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall (referencedTypes :: [*]) x.
MapSchema referencedTypes -&gt; Rep (MapSchema referencedTypes) x
from :: forall x.
MapSchema referencedTypes -&gt; Rep (MapSchema referencedTypes) x
$cto :: forall (referencedTypes :: [*]) x.
Rep (MapSchema referencedTypes) x -&gt; MapSchema referencedTypes
to :: forall x.
Rep (MapSchema referencedTypes) x -&gt; MapSchema referencedTypes
</span
	    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Generics.html#Generic"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Generic</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923396"
      ><span id="local-6989586621679923403"
	><span id="local-6989586621679923410"
	  ><span id="local-6989586621679923412"
	    ><span id="local-6989586621679923414"
	      ><span id="local-6989586621679923419"
		><span id="local-6989586621679923424"
		  ><span id="local-6989586621679923427"
		    ><span id="local-6989586621679923430"
		      ><span id="local-6989586621679923433"
			><span id="local-6989586621679923436"
			  ><span id="local-6989586621679923439"
			    ><span id="local-6989586621679923444"
			      ><span id="local-6989586621679923449"
				><span class="annot"
				  ><span class="annottext"
				    >Typeable (MapSchema referencedTypes)
Typeable (MapSchema referencedTypes) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; MapSchema referencedTypes
 -&gt; c (MapSchema referencedTypes))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (MapSchema referencedTypes))
-&gt; (MapSchema referencedTypes -&gt; Constr)
-&gt; (MapSchema referencedTypes -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d))
    -&gt; Maybe (c (MapSchema referencedTypes)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (MapSchema referencedTypes)))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r
    -&gt; (forall d. Data d =&gt; d -&gt; r')
    -&gt; MapSchema referencedTypes
    -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r
    -&gt; (forall d. Data d =&gt; d -&gt; r')
    -&gt; MapSchema referencedTypes
    -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; MapSchema referencedTypes -&gt; [u])
-&gt; (forall u.
    Int
    -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; MapSchema referencedTypes -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes))
-&gt; Data (MapSchema referencedTypes)
MapSchema referencedTypes -&gt; Constr
MapSchema referencedTypes -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
Typeable (MapSchema referencedTypes)
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
MapSchema referencedTypes -&gt; Constr
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
MapSchema referencedTypes -&gt; DataType
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes
forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; MapSchema referencedTypes -&gt; u
forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; MapSchema referencedTypes -&gt; [u]
forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; MapSchema referencedTypes
-&gt; r
forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; MapSchema referencedTypes
-&gt; r
forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes)
forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes)
forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (MapSchema referencedTypes)
forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; MapSchema referencedTypes
-&gt; c (MapSchema referencedTypes)
forall (referencedTypes :: [*]) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (MapSchema referencedTypes))
forall (referencedTypes :: [*]) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (MapSchema referencedTypes))
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; MapSchema referencedTypes -&gt; u
forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; MapSchema referencedTypes -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; MapSchema referencedTypes
-&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; MapSchema referencedTypes
-&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (MapSchema referencedTypes)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; MapSchema referencedTypes
-&gt; c (MapSchema referencedTypes)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (MapSchema referencedTypes))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (MapSchema referencedTypes))
$cgfoldl :: forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; MapSchema referencedTypes
-&gt; c (MapSchema referencedTypes)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; MapSchema referencedTypes
-&gt; c (MapSchema referencedTypes)
$cgunfold :: forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (MapSchema referencedTypes)
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (MapSchema referencedTypes)
$ctoConstr :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
MapSchema referencedTypes -&gt; Constr
toConstr :: MapSchema referencedTypes -&gt; Constr
$cdataTypeOf :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
MapSchema referencedTypes -&gt; DataType
dataTypeOf :: MapSchema referencedTypes -&gt; DataType
$cdataCast1 :: forall (referencedTypes :: [*]) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (MapSchema referencedTypes))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (MapSchema referencedTypes))
$cdataCast2 :: forall (referencedTypes :: [*]) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (MapSchema referencedTypes))
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (MapSchema referencedTypes))
$cgmapT :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; MapSchema referencedTypes -&gt; MapSchema referencedTypes
$cgmapQl :: forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; MapSchema referencedTypes
-&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; MapSchema referencedTypes
-&gt; r
$cgmapQr :: forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; MapSchema referencedTypes
-&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; MapSchema referencedTypes
-&gt; r
$cgmapQ :: forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; MapSchema referencedTypes -&gt; [u]
gmapQ :: forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; MapSchema referencedTypes -&gt; [u]
$cgmapQi :: forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; MapSchema referencedTypes -&gt; u
gmapQi :: forall u.
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; MapSchema referencedTypes -&gt; u
$cgmapM :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes)
$cgmapMp :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes)
$cgmapMo :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MapSchema referencedTypes -&gt; m (MapSchema referencedTypes)
</span
				    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Data.html#Data"
				    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
				      >Data</span
				      ></a
				    ></span
				  ></span
				></span
			      ></span
			    ></span
			  ></span
			></span
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-217"
      ></span
      ><span
      >
</span
      ><span id="line-218"
      ></span
      ><span class="hs-keyword"
      >data</span
      ><span
      > </span
      ><span id="ConstructorSchema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#ConstructorSchema"
	  ><span class="hs-identifier hs-var"
	    >ConstructorSchema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span id="local-6989586621679922154"
      ><span class="annot"
	><a href="#local-6989586621679922154"
	  ><span class="hs-identifier hs-type"
	    >referencedTypes</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Types.html#Type"
	><span class="hs-identifier hs-type"
	  >Type</span
	  ></a
	></span
      ><span class="hs-special"
      >]</span
      ><span class="hs-special"
      >)</span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span id="MkConstructorSchema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#MkConstructorSchema"
	  ><span class="hs-identifier hs-var"
	    >MkConstructorSchema</span
	    ></a
	  ></span
	></span
      ><span
      >
</span
      ><span id="line-219"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >{</span
      ><span
      > </span
      ><span id="%24sel%3Aindex%3AMkConstructorSchema"
      ><span class="annot"
	><span class="annottext"
	  >forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes -&gt; Natural
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3Aindex%3AMkConstructorSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >index</span
	    ></a
	  ></span
	></span
      ><span
      >        </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-bignum-1.3/docs/src/GHC.Num.Natural.html#Natural"
	><span class="hs-identifier hs-type"
	  >Natural</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-220"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ Constructor index</span
	></span
      ><span
      >
</span
      ><span id="line-221"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3AfieldSchemas%3AMkConstructorSchema"
      ><span class="annot"
	><span class="annottext"
	  >forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes -&gt; [Schema referencedTypes]
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3AfieldSchemas%3AMkConstructorSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >fieldSchemas</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#Schema"
	><span class="hs-identifier hs-type"
	  >Schema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922154"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span class="hs-special"
      >]</span
      ><span
      >
</span
      ><span id="line-222"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ Field schemas</span
	></span
      ><span
      >
</span
      ><span id="line-223"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >}</span
      ><span
      >
</span
      ><span id="line-224"
      ></span
      ><span
      >  </span
      ><span class="hs-keyword"
      >deriving</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-keyword"
	>stock</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span id="local-6989586621679923454"
      ><span id="local-6989586621679923459"
	><span class="annot"
	  ><span class="annottext"
	    >ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
(ConstructorSchema referencedTypes
 -&gt; ConstructorSchema referencedTypes -&gt; Bool)
-&gt; (ConstructorSchema referencedTypes
    -&gt; ConstructorSchema referencedTypes -&gt; Bool)
-&gt; Eq (ConstructorSchema referencedTypes)
forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
== :: ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
$c/= :: forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
/= :: ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
</span
	    ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Eq"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Eq</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923464"
      ><span id="local-6989586621679923469"
	><span id="local-6989586621679923474"
	  ><span id="local-6989586621679923477"
	    ><span id="local-6989586621679923480"
	      ><span id="local-6989586621679923483"
		><span id="local-6989586621679923486"
		  ><span class="annot"
		    ><span class="annottext"
		      >Eq (ConstructorSchema referencedTypes)
Eq (ConstructorSchema referencedTypes) =&gt;
(ConstructorSchema referencedTypes
 -&gt; ConstructorSchema referencedTypes -&gt; Ordering)
-&gt; (ConstructorSchema referencedTypes
    -&gt; ConstructorSchema referencedTypes -&gt; Bool)
-&gt; (ConstructorSchema referencedTypes
    -&gt; ConstructorSchema referencedTypes -&gt; Bool)
-&gt; (ConstructorSchema referencedTypes
    -&gt; ConstructorSchema referencedTypes -&gt; Bool)
-&gt; (ConstructorSchema referencedTypes
    -&gt; ConstructorSchema referencedTypes -&gt; Bool)
-&gt; (ConstructorSchema referencedTypes
    -&gt; ConstructorSchema referencedTypes
    -&gt; ConstructorSchema referencedTypes)
-&gt; (ConstructorSchema referencedTypes
    -&gt; ConstructorSchema referencedTypes
    -&gt; ConstructorSchema referencedTypes)
-&gt; Ord (ConstructorSchema referencedTypes)
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Ordering
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
forall (referencedTypes :: [*]).
Eq (ConstructorSchema referencedTypes)
forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Ordering
forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Ordering
compare :: ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Ordering
$c&lt; :: forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
&lt; :: ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
$c&lt;= :: forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
&lt;= :: ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
$c&gt; :: forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
&gt; :: ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
$c&gt;= :: forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
&gt;= :: ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes -&gt; Bool
$cmax :: forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
max :: ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
$cmin :: forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
min :: ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
</span
		      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Ord"
		      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
			>Ord</span
			></a
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923489"
      ><span id="local-6989586621679923495"
	><span id="local-6989586621679923498"
	  ><span class="annot"
	    ><span class="annottext"
	      >Int -&gt; ConstructorSchema referencedTypes -&gt; ShowS
[ConstructorSchema referencedTypes] -&gt; ShowS
ConstructorSchema referencedTypes -&gt; String
(Int -&gt; ConstructorSchema referencedTypes -&gt; ShowS)
-&gt; (ConstructorSchema referencedTypes -&gt; String)
-&gt; ([ConstructorSchema referencedTypes] -&gt; ShowS)
-&gt; Show (ConstructorSchema referencedTypes)
forall (referencedTypes :: [*]).
Int -&gt; ConstructorSchema referencedTypes -&gt; ShowS
forall (referencedTypes :: [*]).
[ConstructorSchema referencedTypes] -&gt; ShowS
forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: forall (referencedTypes :: [*]).
Int -&gt; ConstructorSchema referencedTypes -&gt; ShowS
showsPrec :: Int -&gt; ConstructorSchema referencedTypes -&gt; ShowS
$cshow :: forall (referencedTypes :: [*]).
ConstructorSchema referencedTypes -&gt; String
show :: ConstructorSchema referencedTypes -&gt; String
$cshowList :: forall (referencedTypes :: [*]).
[ConstructorSchema referencedTypes] -&gt; ShowS
showList :: [ConstructorSchema referencedTypes] -&gt; ShowS
</span
	      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Show.html#Show"
	      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
		>Show</span
		></a
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923501"
      ><span id="local-6989586621679923503"
	><span class="annot"
	  ><span class="annottext"
	    >(forall x.
 ConstructorSchema referencedTypes
 -&gt; Rep (ConstructorSchema referencedTypes) x)
-&gt; (forall x.
    Rep (ConstructorSchema referencedTypes) x
    -&gt; ConstructorSchema referencedTypes)
-&gt; Generic (ConstructorSchema referencedTypes)
forall (referencedTypes :: [*]) x.
Rep (ConstructorSchema referencedTypes) x
-&gt; ConstructorSchema referencedTypes
forall (referencedTypes :: [*]) x.
ConstructorSchema referencedTypes
-&gt; Rep (ConstructorSchema referencedTypes) x
forall x.
Rep (ConstructorSchema referencedTypes) x
-&gt; ConstructorSchema referencedTypes
forall x.
ConstructorSchema referencedTypes
-&gt; Rep (ConstructorSchema referencedTypes) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall (referencedTypes :: [*]) x.
ConstructorSchema referencedTypes
-&gt; Rep (ConstructorSchema referencedTypes) x
from :: forall x.
ConstructorSchema referencedTypes
-&gt; Rep (ConstructorSchema referencedTypes) x
$cto :: forall (referencedTypes :: [*]) x.
Rep (ConstructorSchema referencedTypes) x
-&gt; ConstructorSchema referencedTypes
to :: forall x.
Rep (ConstructorSchema referencedTypes) x
-&gt; ConstructorSchema referencedTypes
</span
	    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Generics.html#Generic"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Generic</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923510"
      ><span id="local-6989586621679923515"
	><span id="local-6989586621679923520"
	  ><span id="local-6989586621679923522"
	    ><span id="local-6989586621679923524"
	      ><span id="local-6989586621679923529"
		><span id="local-6989586621679923534"
		  ><span id="local-6989586621679923537"
		    ><span id="local-6989586621679923540"
		      ><span id="local-6989586621679923543"
			><span id="local-6989586621679923546"
			  ><span id="local-6989586621679923549"
			    ><span id="local-6989586621679923554"
			      ><span id="local-6989586621679923559"
				><span class="annot"
				  ><span class="annottext"
				    >Typeable (ConstructorSchema referencedTypes)
Typeable (ConstructorSchema referencedTypes) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; ConstructorSchema referencedTypes
 -&gt; c (ConstructorSchema referencedTypes))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r)
    -&gt; Constr
    -&gt; c (ConstructorSchema referencedTypes))
-&gt; (ConstructorSchema referencedTypes -&gt; Constr)
-&gt; (ConstructorSchema referencedTypes -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d))
    -&gt; Maybe (c (ConstructorSchema referencedTypes)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (ConstructorSchema referencedTypes)))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; ConstructorSchema referencedTypes
    -&gt; ConstructorSchema referencedTypes)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r
    -&gt; (forall d. Data d =&gt; d -&gt; r')
    -&gt; ConstructorSchema referencedTypes
    -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r
    -&gt; (forall d. Data d =&gt; d -&gt; r')
    -&gt; ConstructorSchema referencedTypes
    -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u)
    -&gt; ConstructorSchema referencedTypes -&gt; [u])
-&gt; (forall u.
    Int
    -&gt; (forall d. Data d =&gt; d -&gt; u)
    -&gt; ConstructorSchema referencedTypes
    -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorSchema referencedTypes
    -&gt; m (ConstructorSchema referencedTypes))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorSchema referencedTypes
    -&gt; m (ConstructorSchema referencedTypes))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorSchema referencedTypes
    -&gt; m (ConstructorSchema referencedTypes))
-&gt; Data (ConstructorSchema referencedTypes)
ConstructorSchema referencedTypes -&gt; Constr
ConstructorSchema referencedTypes -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
Typeable (ConstructorSchema referencedTypes)
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
ConstructorSchema referencedTypes -&gt; Constr
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
ConstructorSchema referencedTypes -&gt; DataType
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
Int
-&gt; (forall d. Data d =&gt; d -&gt; u)
-&gt; ConstructorSchema referencedTypes
-&gt; u
forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
(forall d. Data d =&gt; d -&gt; u)
-&gt; ConstructorSchema referencedTypes -&gt; [u]
forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ConstructorSchema referencedTypes
-&gt; r
forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ConstructorSchema referencedTypes
-&gt; r
forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorSchema referencedTypes
-&gt; m (ConstructorSchema referencedTypes)
forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorSchema referencedTypes
-&gt; m (ConstructorSchema referencedTypes)
forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r)
-&gt; Constr
-&gt; c (ConstructorSchema referencedTypes)
forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ConstructorSchema referencedTypes
-&gt; c (ConstructorSchema referencedTypes)
forall (referencedTypes :: [*]) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (ConstructorSchema referencedTypes))
forall (referencedTypes :: [*]) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ConstructorSchema referencedTypes))
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int
-&gt; (forall d. Data d =&gt; d -&gt; u)
-&gt; ConstructorSchema referencedTypes
-&gt; u
forall u.
(forall d. Data d =&gt; d -&gt; u)
-&gt; ConstructorSchema referencedTypes -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ConstructorSchema referencedTypes
-&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ConstructorSchema referencedTypes
-&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorSchema referencedTypes
-&gt; m (ConstructorSchema referencedTypes)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorSchema referencedTypes
-&gt; m (ConstructorSchema referencedTypes)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r)
-&gt; Constr
-&gt; c (ConstructorSchema referencedTypes)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ConstructorSchema referencedTypes
-&gt; c (ConstructorSchema referencedTypes)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (ConstructorSchema referencedTypes))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ConstructorSchema referencedTypes))
$cgfoldl :: forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ConstructorSchema referencedTypes
-&gt; c (ConstructorSchema referencedTypes)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ConstructorSchema referencedTypes
-&gt; c (ConstructorSchema referencedTypes)
$cgunfold :: forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r)
-&gt; Constr
-&gt; c (ConstructorSchema referencedTypes)
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r)
-&gt; Constr
-&gt; c (ConstructorSchema referencedTypes)
$ctoConstr :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
ConstructorSchema referencedTypes -&gt; Constr
toConstr :: ConstructorSchema referencedTypes -&gt; Constr
$cdataTypeOf :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
ConstructorSchema referencedTypes -&gt; DataType
dataTypeOf :: ConstructorSchema referencedTypes -&gt; DataType
$cdataCast1 :: forall (referencedTypes :: [*]) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (ConstructorSchema referencedTypes))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (ConstructorSchema referencedTypes))
$cdataCast2 :: forall (referencedTypes :: [*]) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ConstructorSchema referencedTypes))
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ConstructorSchema referencedTypes))
$cgmapT :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; ConstructorSchema referencedTypes
-&gt; ConstructorSchema referencedTypes
$cgmapQl :: forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ConstructorSchema referencedTypes
-&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ConstructorSchema referencedTypes
-&gt; r
$cgmapQr :: forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ConstructorSchema referencedTypes
-&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; ConstructorSchema referencedTypes
-&gt; r
$cgmapQ :: forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
(forall d. Data d =&gt; d -&gt; u)
-&gt; ConstructorSchema referencedTypes -&gt; [u]
gmapQ :: forall u.
(forall d. Data d =&gt; d -&gt; u)
-&gt; ConstructorSchema referencedTypes -&gt; [u]
$cgmapQi :: forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
Int
-&gt; (forall d. Data d =&gt; d -&gt; u)
-&gt; ConstructorSchema referencedTypes
-&gt; u
gmapQi :: forall u.
Int
-&gt; (forall d. Data d =&gt; d -&gt; u)
-&gt; ConstructorSchema referencedTypes
-&gt; u
$cgmapM :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorSchema referencedTypes
-&gt; m (ConstructorSchema referencedTypes)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorSchema referencedTypes
-&gt; m (ConstructorSchema referencedTypes)
$cgmapMp :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorSchema referencedTypes
-&gt; m (ConstructorSchema referencedTypes)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorSchema referencedTypes
-&gt; m (ConstructorSchema referencedTypes)
$cgmapMo :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorSchema referencedTypes
-&gt; m (ConstructorSchema referencedTypes)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorSchema referencedTypes
-&gt; m (ConstructorSchema referencedTypes)
</span
				    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Data.html#Data"
				    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
				      >Data</span
				      ></a
				    ></span
				  ></span
				></span
			      ></span
			    ></span
			  ></span
			></span
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-225"
      ></span
      ><span
      >
</span
      ><span id="line-226"
      ></span
      ><span class="hs-keyword"
      >data</span
      ><span
      > </span
      ><span id="PairSchema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#PairSchema"
	  ><span class="hs-identifier hs-var"
	    >PairSchema</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span id="local-6989586621679922158"
      ><span class="annot"
	><a href="#local-6989586621679922158"
	  ><span class="hs-identifier hs-type"
	    >referencedTypes</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="hs-special"
      >[</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Types.html#Type"
	><span class="hs-identifier hs-type"
	  >Type</span
	  ></a
	></span
      ><span class="hs-special"
      >]</span
      ><span class="hs-special"
      >)</span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span id="MkPairSchema"
      ><span class="annot"
	><a href="PlutusTx.Blueprint.Schema.html#MkPairSchema"
	  ><span class="hs-identifier hs-var"
	    >MkPairSchema</span
	    ></a
	  ></span
	></span
      ><span
      >
</span
      ><span id="line-227"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >{</span
      ><span
      > </span
      ><span id="%24sel%3Aleft%3AMkPairSchema"
      ><span class="annot"
	><span class="annottext"
	  >forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; Schema referencedTypes
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3Aleft%3AMkPairSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >left</span
	    ></a
	  ></span
	></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#Schema"
	><span class="hs-identifier hs-type"
	  >Schema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922158"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-228"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ Schema of the first element</span
	></span
      ><span
      >
</span
      ><span id="line-229"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="%24sel%3Aright%3AMkPairSchema"
      ><span class="annot"
	><span class="annottext"
	  >forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; Schema referencedTypes
</span
	  ><a href="PlutusTx.Blueprint.Schema.html#%24sel%3Aright%3AMkPairSchema"
	  ><span class="hs-identifier hs-var hs-var"
	    >right</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="PlutusTx.Blueprint.Schema.html#Schema"
	><span class="hs-identifier hs-type"
	  >Schema</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621679922158"
	><span class="hs-identifier hs-type"
	  >referencedTypes</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-230"
      ></span
      ><span
      >  </span
      ><span class="annot"
      ><span class="hs-comment"
	>-- ^ Schema of the second element</span
	></span
      ><span
      >
</span
      ><span id="line-231"
      ></span
      ><span
      >  </span
      ><span class="hs-special"
      >}</span
      ><span
      >
</span
      ><span id="line-232"
      ></span
      ><span
      >  </span
      ><span class="hs-keyword"
      >deriving</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-keyword"
	>stock</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span id="local-6989586621679923564"
      ><span id="local-6989586621679923568"
	><span class="annot"
	  ><span class="annottext"
	    >PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
(PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool)
-&gt; (PairSchema referencedTypes
    -&gt; PairSchema referencedTypes -&gt; Bool)
-&gt; Eq (PairSchema referencedTypes)
forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
== :: PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
$c/= :: forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
/= :: PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
</span
	    ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Eq"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Eq</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923573"
      ><span id="local-6989586621679923577"
	><span id="local-6989586621679923581"
	  ><span id="local-6989586621679923584"
	    ><span id="local-6989586621679923587"
	      ><span id="local-6989586621679923590"
		><span id="local-6989586621679923593"
		  ><span class="annot"
		    ><span class="annottext"
		      >Eq (PairSchema referencedTypes)
Eq (PairSchema referencedTypes) =&gt;
(PairSchema referencedTypes
 -&gt; PairSchema referencedTypes -&gt; Ordering)
-&gt; (PairSchema referencedTypes
    -&gt; PairSchema referencedTypes -&gt; Bool)
-&gt; (PairSchema referencedTypes
    -&gt; PairSchema referencedTypes -&gt; Bool)
-&gt; (PairSchema referencedTypes
    -&gt; PairSchema referencedTypes -&gt; Bool)
-&gt; (PairSchema referencedTypes
    -&gt; PairSchema referencedTypes -&gt; Bool)
-&gt; (PairSchema referencedTypes
    -&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes)
-&gt; (PairSchema referencedTypes
    -&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes)
-&gt; Ord (PairSchema referencedTypes)
PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
PairSchema referencedTypes
-&gt; PairSchema referencedTypes -&gt; Ordering
PairSchema referencedTypes
-&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes
forall (referencedTypes :: [*]). Eq (PairSchema referencedTypes)
forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
forall (referencedTypes :: [*]).
PairSchema referencedTypes
-&gt; PairSchema referencedTypes -&gt; Ordering
forall (referencedTypes :: [*]).
PairSchema referencedTypes
-&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: forall (referencedTypes :: [*]).
PairSchema referencedTypes
-&gt; PairSchema referencedTypes -&gt; Ordering
compare :: PairSchema referencedTypes
-&gt; PairSchema referencedTypes -&gt; Ordering
$c&lt; :: forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
&lt; :: PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
$c&lt;= :: forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
&lt;= :: PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
$c&gt; :: forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
&gt; :: PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
$c&gt;= :: forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
&gt;= :: PairSchema referencedTypes -&gt; PairSchema referencedTypes -&gt; Bool
$cmax :: forall (referencedTypes :: [*]).
PairSchema referencedTypes
-&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes
max :: PairSchema referencedTypes
-&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes
$cmin :: forall (referencedTypes :: [*]).
PairSchema referencedTypes
-&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes
min :: PairSchema referencedTypes
-&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes
</span
		      ><a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Classes.html#Ord"
		      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
			>Ord</span
			></a
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923596"
      ><span id="local-6989586621679923601"
	><span id="local-6989586621679923604"
	  ><span class="annot"
	    ><span class="annottext"
	      >Int -&gt; PairSchema referencedTypes -&gt; ShowS
[PairSchema referencedTypes] -&gt; ShowS
PairSchema referencedTypes -&gt; String
(Int -&gt; PairSchema referencedTypes -&gt; ShowS)
-&gt; (PairSchema referencedTypes -&gt; String)
-&gt; ([PairSchema referencedTypes] -&gt; ShowS)
-&gt; Show (PairSchema referencedTypes)
forall (referencedTypes :: [*]).
Int -&gt; PairSchema referencedTypes -&gt; ShowS
forall (referencedTypes :: [*]).
[PairSchema referencedTypes] -&gt; ShowS
forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: forall (referencedTypes :: [*]).
Int -&gt; PairSchema referencedTypes -&gt; ShowS
showsPrec :: Int -&gt; PairSchema referencedTypes -&gt; ShowS
$cshow :: forall (referencedTypes :: [*]).
PairSchema referencedTypes -&gt; String
show :: PairSchema referencedTypes -&gt; String
$cshowList :: forall (referencedTypes :: [*]).
[PairSchema referencedTypes] -&gt; ShowS
showList :: [PairSchema referencedTypes] -&gt; ShowS
</span
	      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Show.html#Show"
	      ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
		>Show</span
		></a
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923607"
      ><span id="local-6989586621679923609"
	><span class="annot"
	  ><span class="annottext"
	    >(forall x.
 PairSchema referencedTypes -&gt; Rep (PairSchema referencedTypes) x)
-&gt; (forall x.
    Rep (PairSchema referencedTypes) x -&gt; PairSchema referencedTypes)
-&gt; Generic (PairSchema referencedTypes)
forall (referencedTypes :: [*]) x.
Rep (PairSchema referencedTypes) x -&gt; PairSchema referencedTypes
forall (referencedTypes :: [*]) x.
PairSchema referencedTypes -&gt; Rep (PairSchema referencedTypes) x
forall x.
Rep (PairSchema referencedTypes) x -&gt; PairSchema referencedTypes
forall x.
PairSchema referencedTypes -&gt; Rep (PairSchema referencedTypes) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall (referencedTypes :: [*]) x.
PairSchema referencedTypes -&gt; Rep (PairSchema referencedTypes) x
from :: forall x.
PairSchema referencedTypes -&gt; Rep (PairSchema referencedTypes) x
$cto :: forall (referencedTypes :: [*]) x.
Rep (PairSchema referencedTypes) x -&gt; PairSchema referencedTypes
to :: forall x.
Rep (PairSchema referencedTypes) x -&gt; PairSchema referencedTypes
</span
	    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Generics.html#Generic"
	    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var"
	      >Generic</span
	      ></a
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span id="local-6989586621679923616"
      ><span id="local-6989586621679923620"
	><span id="local-6989586621679923624"
	  ><span id="local-6989586621679923626"
	    ><span id="local-6989586621679923628"
	      ><span id="local-6989586621679923633"
		><span id="local-6989586621679923638"
		  ><span id="local-6989586621679923641"
		    ><span id="local-6989586621679923644"
		      ><span id="local-6989586621679923647"
			><span id="local-6989586621679923650"
			  ><span id="local-6989586621679923653"
			    ><span id="local-6989586621679923658"
			      ><span id="local-6989586621679923663"
				><span class="annot"
				  ><span class="annottext"
				    >Typeable (PairSchema referencedTypes)
Typeable (PairSchema referencedTypes) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; PairSchema referencedTypes
 -&gt; c (PairSchema referencedTypes))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r)
    -&gt; Constr
    -&gt; c (PairSchema referencedTypes))
-&gt; (PairSchema referencedTypes -&gt; Constr)
-&gt; (PairSchema referencedTypes -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d))
    -&gt; Maybe (c (PairSchema referencedTypes)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (PairSchema referencedTypes)))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r
    -&gt; (forall d. Data d =&gt; d -&gt; r')
    -&gt; PairSchema referencedTypes
    -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r
    -&gt; (forall d. Data d =&gt; d -&gt; r')
    -&gt; PairSchema referencedTypes
    -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; PairSchema referencedTypes -&gt; [u])
-&gt; (forall u.
    Int
    -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PairSchema referencedTypes -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes))
-&gt; Data (PairSchema referencedTypes)
PairSchema referencedTypes -&gt; Constr
PairSchema referencedTypes -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
Typeable (PairSchema referencedTypes)
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
PairSchema referencedTypes -&gt; Constr
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
PairSchema referencedTypes -&gt; DataType
forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes
forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PairSchema referencedTypes -&gt; u
forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; PairSchema referencedTypes -&gt; [u]
forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; PairSchema referencedTypes
-&gt; r
forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; PairSchema referencedTypes
-&gt; r
forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes)
forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes)
forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PairSchema referencedTypes)
forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; PairSchema referencedTypes
-&gt; c (PairSchema referencedTypes)
forall (referencedTypes :: [*]) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (PairSchema referencedTypes))
forall (referencedTypes :: [*]) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (PairSchema referencedTypes))
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PairSchema referencedTypes -&gt; u
forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; PairSchema referencedTypes -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; PairSchema referencedTypes
-&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; PairSchema referencedTypes
-&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PairSchema referencedTypes)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; PairSchema referencedTypes
-&gt; c (PairSchema referencedTypes)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (PairSchema referencedTypes))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (PairSchema referencedTypes))
$cgfoldl :: forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; PairSchema referencedTypes
-&gt; c (PairSchema referencedTypes)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; PairSchema referencedTypes
-&gt; c (PairSchema referencedTypes)
$cgunfold :: forall (referencedTypes :: [*]) (c :: * -&gt; *).
Typeable referencedTypes =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PairSchema referencedTypes)
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PairSchema referencedTypes)
$ctoConstr :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
PairSchema referencedTypes -&gt; Constr
toConstr :: PairSchema referencedTypes -&gt; Constr
$cdataTypeOf :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
PairSchema referencedTypes -&gt; DataType
dataTypeOf :: PairSchema referencedTypes -&gt; DataType
$cdataCast1 :: forall (referencedTypes :: [*]) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (PairSchema referencedTypes))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (PairSchema referencedTypes))
$cdataCast2 :: forall (referencedTypes :: [*]) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable referencedTypes, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (PairSchema referencedTypes))
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (PairSchema referencedTypes))
$cgmapT :: forall (referencedTypes :: [*]).
Typeable referencedTypes =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; PairSchema referencedTypes -&gt; PairSchema referencedTypes
$cgmapQl :: forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; PairSchema referencedTypes
-&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; PairSchema referencedTypes
-&gt; r
$cgmapQr :: forall (referencedTypes :: [*]) r r'.
Typeable referencedTypes =&gt;
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; PairSchema referencedTypes
-&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; PairSchema referencedTypes
-&gt; r
$cgmapQ :: forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; PairSchema referencedTypes -&gt; [u]
gmapQ :: forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; PairSchema referencedTypes -&gt; [u]
$cgmapQi :: forall (referencedTypes :: [*]) u.
Typeable referencedTypes =&gt;
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PairSchema referencedTypes -&gt; u
gmapQi :: forall u.
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PairSchema referencedTypes -&gt; u
$cgmapM :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes)
$cgmapMp :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes)
$cgmapMo :: forall (referencedTypes :: [*]) (m :: * -&gt; *).
(Typeable referencedTypes, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PairSchema referencedTypes -&gt; m (PairSchema referencedTypes)
</span
				    ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Data.html#Data"
				    ><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var"
				      >Data</span
				      ></a
				    ></span
				  ></span
				></span
			      ></span
			    ></span
			  ></span
			></span
		      ></span
		    ></span
		  ></span
		></span
	      ></span
	    ></span
	  ></span
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-233"
      ></span
      ></pre
    ></body
  ></html
>
